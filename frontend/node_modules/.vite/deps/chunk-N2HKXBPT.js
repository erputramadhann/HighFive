import {
  require_jsx_runtime
} from "./chunk-OT5EQO2H.js";
import {
  require_react_dom
} from "./chunk-TH7NCS4R.js";
import {
  require_react
} from "./chunk-OU5AQDZK.js";
import {
  __commonJS,
  __export,
  __publicField,
  __toESM
} from "./chunk-EWTE5DHJ.js";

// node_modules/@react-native/normalize-color/index.js
var require_normalize_color = __commonJS({
  "node_modules/@react-native/normalize-color/index.js"(exports, module) {
    "use strict";
    function normalizeColor3(color) {
      if (typeof color === "number") {
        if (color >>> 0 === color && color >= 0 && color <= 4294967295) {
          return color;
        }
        return null;
      }
      if (typeof color !== "string") {
        return null;
      }
      const matchers = getMatchers();
      let match;
      if (match = matchers.hex6.exec(color)) {
        return parseInt(match[1] + "ff", 16) >>> 0;
      }
      const colorFromKeyword = normalizeKeyword(color);
      if (colorFromKeyword != null) {
        return colorFromKeyword;
      }
      if (match = matchers.rgb.exec(color)) {
        return (parse255(match[1]) << 24 | // r
        parse255(match[2]) << 16 | // g
        parse255(match[3]) << 8 | // b
        255) >>> // a
        0;
      }
      if (match = matchers.rgba.exec(color)) {
        if (match[6] !== void 0) {
          return (parse255(match[6]) << 24 | // r
          parse255(match[7]) << 16 | // g
          parse255(match[8]) << 8 | // b
          parse1(match[9])) >>> // a
          0;
        }
        return (parse255(match[2]) << 24 | // r
        parse255(match[3]) << 16 | // g
        parse255(match[4]) << 8 | // b
        parse1(match[5])) >>> // a
        0;
      }
      if (match = matchers.hex3.exec(color)) {
        return parseInt(
          match[1] + match[1] + // r
          match[2] + match[2] + // g
          match[3] + match[3] + // b
          "ff",
          // a
          16
        ) >>> 0;
      }
      if (match = matchers.hex8.exec(color)) {
        return parseInt(match[1], 16) >>> 0;
      }
      if (match = matchers.hex4.exec(color)) {
        return parseInt(
          match[1] + match[1] + // r
          match[2] + match[2] + // g
          match[3] + match[3] + // b
          match[4] + match[4],
          // a
          16
        ) >>> 0;
      }
      if (match = matchers.hsl.exec(color)) {
        return (hslToRgb(
          parse360(match[1]),
          // h
          parsePercentage(match[2]),
          // s
          parsePercentage(match[3])
          // l
        ) | 255) >>> // a
        0;
      }
      if (match = matchers.hsla.exec(color)) {
        if (match[6] !== void 0) {
          return (hslToRgb(
            parse360(match[6]),
            // h
            parsePercentage(match[7]),
            // s
            parsePercentage(match[8])
            // l
          ) | parse1(match[9])) >>> // a
          0;
        }
        return (hslToRgb(
          parse360(match[2]),
          // h
          parsePercentage(match[3]),
          // s
          parsePercentage(match[4])
          // l
        ) | parse1(match[5])) >>> // a
        0;
      }
      if (match = matchers.hwb.exec(color)) {
        return (hwbToRgb(
          parse360(match[1]),
          // h
          parsePercentage(match[2]),
          // w
          parsePercentage(match[3])
          // b
        ) | 255) >>> // a
        0;
      }
      return null;
    }
    function hue2rgb(p, q, t) {
      if (t < 0) {
        t += 1;
      }
      if (t > 1) {
        t -= 1;
      }
      if (t < 1 / 6) {
        return p + (q - p) * 6 * t;
      }
      if (t < 1 / 2) {
        return q;
      }
      if (t < 2 / 3) {
        return p + (q - p) * (2 / 3 - t) * 6;
      }
      return p;
    }
    function hslToRgb(h, s, l) {
      const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
      const p = 2 * l - q;
      const r = hue2rgb(p, q, h + 1 / 3);
      const g = hue2rgb(p, q, h);
      const b = hue2rgb(p, q, h - 1 / 3);
      return Math.round(r * 255) << 24 | Math.round(g * 255) << 16 | Math.round(b * 255) << 8;
    }
    function hwbToRgb(h, w, b) {
      if (w + b >= 1) {
        const gray = Math.round(w * 255 / (w + b));
        return gray << 24 | gray << 16 | gray << 8;
      }
      const red = hue2rgb(0, 1, h + 1 / 3) * (1 - w - b) + w;
      const green = hue2rgb(0, 1, h) * (1 - w - b) + w;
      const blue = hue2rgb(0, 1, h - 1 / 3) * (1 - w - b) + w;
      return Math.round(red * 255) << 24 | Math.round(green * 255) << 16 | Math.round(blue * 255) << 8;
    }
    var NUMBER = "[-+]?\\d*\\.?\\d+";
    var PERCENTAGE = NUMBER + "%";
    function call(...args) {
      return "\\(\\s*(" + args.join(")\\s*,?\\s*(") + ")\\s*\\)";
    }
    function callWithSlashSeparator(...args) {
      return "\\(\\s*(" + args.slice(0, args.length - 1).join(")\\s*,?\\s*(") + ")\\s*/\\s*(" + args[args.length - 1] + ")\\s*\\)";
    }
    function commaSeparatedCall(...args) {
      return "\\(\\s*(" + args.join(")\\s*,\\s*(") + ")\\s*\\)";
    }
    var cachedMatchers;
    function getMatchers() {
      if (cachedMatchers === void 0) {
        cachedMatchers = {
          rgb: new RegExp("rgb" + call(NUMBER, NUMBER, NUMBER)),
          rgba: new RegExp(
            "rgba(" + commaSeparatedCall(NUMBER, NUMBER, NUMBER, NUMBER) + "|" + callWithSlashSeparator(NUMBER, NUMBER, NUMBER, NUMBER) + ")"
          ),
          hsl: new RegExp("hsl" + call(NUMBER, PERCENTAGE, PERCENTAGE)),
          hsla: new RegExp(
            "hsla(" + commaSeparatedCall(NUMBER, PERCENTAGE, PERCENTAGE, NUMBER) + "|" + callWithSlashSeparator(NUMBER, PERCENTAGE, PERCENTAGE, NUMBER) + ")"
          ),
          hwb: new RegExp("hwb" + call(NUMBER, PERCENTAGE, PERCENTAGE)),
          hex3: /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
          hex4: /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
          hex6: /^#([0-9a-fA-F]{6})$/,
          hex8: /^#([0-9a-fA-F]{8})$/
        };
      }
      return cachedMatchers;
    }
    function parse255(str) {
      const int = parseInt(str, 10);
      if (int < 0) {
        return 0;
      }
      if (int > 255) {
        return 255;
      }
      return int;
    }
    function parse360(str) {
      const int = parseFloat(str);
      return (int % 360 + 360) % 360 / 360;
    }
    function parse1(str) {
      const num = parseFloat(str);
      if (num < 0) {
        return 0;
      }
      if (num > 1) {
        return 255;
      }
      return Math.round(num * 255);
    }
    function parsePercentage(str) {
      const int = parseFloat(str);
      if (int < 0) {
        return 0;
      }
      if (int > 100) {
        return 1;
      }
      return int / 100;
    }
    function normalizeKeyword(name) {
      switch (name) {
        case "transparent":
          return 0;
        // http://www.w3.org/TR/css3-color/#svg-color
        case "aliceblue":
          return 4042850303;
        case "antiquewhite":
          return 4209760255;
        case "aqua":
          return 16777215;
        case "aquamarine":
          return 2147472639;
        case "azure":
          return 4043309055;
        case "beige":
          return 4126530815;
        case "bisque":
          return 4293182719;
        case "black":
          return 255;
        case "blanchedalmond":
          return 4293643775;
        case "blue":
          return 65535;
        case "blueviolet":
          return 2318131967;
        case "brown":
          return 2771004159;
        case "burlywood":
          return 3736635391;
        case "burntsienna":
          return 3934150143;
        case "cadetblue":
          return 1604231423;
        case "chartreuse":
          return 2147418367;
        case "chocolate":
          return 3530104575;
        case "coral":
          return 4286533887;
        case "cornflowerblue":
          return 1687547391;
        case "cornsilk":
          return 4294499583;
        case "crimson":
          return 3692313855;
        case "cyan":
          return 16777215;
        case "darkblue":
          return 35839;
        case "darkcyan":
          return 9145343;
        case "darkgoldenrod":
          return 3095792639;
        case "darkgray":
          return 2846468607;
        case "darkgreen":
          return 6553855;
        case "darkgrey":
          return 2846468607;
        case "darkkhaki":
          return 3182914559;
        case "darkmagenta":
          return 2332068863;
        case "darkolivegreen":
          return 1433087999;
        case "darkorange":
          return 4287365375;
        case "darkorchid":
          return 2570243327;
        case "darkred":
          return 2332033279;
        case "darksalmon":
          return 3918953215;
        case "darkseagreen":
          return 2411499519;
        case "darkslateblue":
          return 1211993087;
        case "darkslategray":
          return 793726975;
        case "darkslategrey":
          return 793726975;
        case "darkturquoise":
          return 13554175;
        case "darkviolet":
          return 2483082239;
        case "deeppink":
          return 4279538687;
        case "deepskyblue":
          return 12582911;
        case "dimgray":
          return 1768516095;
        case "dimgrey":
          return 1768516095;
        case "dodgerblue":
          return 512819199;
        case "firebrick":
          return 2988581631;
        case "floralwhite":
          return 4294635775;
        case "forestgreen":
          return 579543807;
        case "fuchsia":
          return 4278255615;
        case "gainsboro":
          return 3705462015;
        case "ghostwhite":
          return 4177068031;
        case "gold":
          return 4292280575;
        case "goldenrod":
          return 3668254975;
        case "gray":
          return 2155905279;
        case "green":
          return 8388863;
        case "greenyellow":
          return 2919182335;
        case "grey":
          return 2155905279;
        case "honeydew":
          return 4043305215;
        case "hotpink":
          return 4285117695;
        case "indianred":
          return 3445382399;
        case "indigo":
          return 1258324735;
        case "ivory":
          return 4294963455;
        case "khaki":
          return 4041641215;
        case "lavender":
          return 3873897215;
        case "lavenderblush":
          return 4293981695;
        case "lawngreen":
          return 2096890111;
        case "lemonchiffon":
          return 4294626815;
        case "lightblue":
          return 2916673279;
        case "lightcoral":
          return 4034953471;
        case "lightcyan":
          return 3774873599;
        case "lightgoldenrodyellow":
          return 4210742015;
        case "lightgray":
          return 3553874943;
        case "lightgreen":
          return 2431553791;
        case "lightgrey":
          return 3553874943;
        case "lightpink":
          return 4290167295;
        case "lightsalmon":
          return 4288707327;
        case "lightseagreen":
          return 548580095;
        case "lightskyblue":
          return 2278488831;
        case "lightslategray":
          return 2005441023;
        case "lightslategrey":
          return 2005441023;
        case "lightsteelblue":
          return 2965692159;
        case "lightyellow":
          return 4294959359;
        case "lime":
          return 16711935;
        case "limegreen":
          return 852308735;
        case "linen":
          return 4210091775;
        case "magenta":
          return 4278255615;
        case "maroon":
          return 2147483903;
        case "mediumaquamarine":
          return 1724754687;
        case "mediumblue":
          return 52735;
        case "mediumorchid":
          return 3126187007;
        case "mediumpurple":
          return 2473647103;
        case "mediumseagreen":
          return 1018393087;
        case "mediumslateblue":
          return 2070474495;
        case "mediumspringgreen":
          return 16423679;
        case "mediumturquoise":
          return 1221709055;
        case "mediumvioletred":
          return 3340076543;
        case "midnightblue":
          return 421097727;
        case "mintcream":
          return 4127193855;
        case "mistyrose":
          return 4293190143;
        case "moccasin":
          return 4293178879;
        case "navajowhite":
          return 4292783615;
        case "navy":
          return 33023;
        case "oldlace":
          return 4260751103;
        case "olive":
          return 2155872511;
        case "olivedrab":
          return 1804477439;
        case "orange":
          return 4289003775;
        case "orangered":
          return 4282712319;
        case "orchid":
          return 3664828159;
        case "palegoldenrod":
          return 4008225535;
        case "palegreen":
          return 2566625535;
        case "paleturquoise":
          return 2951671551;
        case "palevioletred":
          return 3681588223;
        case "papayawhip":
          return 4293907967;
        case "peachpuff":
          return 4292524543;
        case "peru":
          return 3448061951;
        case "pink":
          return 4290825215;
        case "plum":
          return 3718307327;
        case "powderblue":
          return 2967529215;
        case "purple":
          return 2147516671;
        case "rebeccapurple":
          return 1714657791;
        case "red":
          return 4278190335;
        case "rosybrown":
          return 3163525119;
        case "royalblue":
          return 1097458175;
        case "saddlebrown":
          return 2336560127;
        case "salmon":
          return 4202722047;
        case "sandybrown":
          return 4104413439;
        case "seagreen":
          return 780883967;
        case "seashell":
          return 4294307583;
        case "sienna":
          return 2689740287;
        case "silver":
          return 3233857791;
        case "skyblue":
          return 2278484991;
        case "slateblue":
          return 1784335871;
        case "slategray":
          return 1887473919;
        case "slategrey":
          return 1887473919;
        case "snow":
          return 4294638335;
        case "springgreen":
          return 16744447;
        case "steelblue":
          return 1182971135;
        case "tan":
          return 3535047935;
        case "teal":
          return 8421631;
        case "thistle":
          return 3636451583;
        case "tomato":
          return 4284696575;
        case "turquoise":
          return 1088475391;
        case "violet":
          return 4001558271;
        case "wheat":
          return 4125012991;
        case "white":
          return 4294967295;
        case "whitesmoke":
          return 4126537215;
        case "yellow":
          return 4294902015;
        case "yellowgreen":
          return 2597139199;
      }
      return null;
    }
    module.exports = normalizeColor3;
  }
});

// node_modules/@tamagui/timer/dist/cjs/index.cjs
var require_cjs = __commonJS({
  "node_modules/@tamagui/timer/dist/cjs/index.cjs"(exports, module) {
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export2 = (target, all2) => {
      for (var name in all2) __defProp(target, name, {
        get: all2[name],
        enumerable: true
      });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from == "object" || typeof from == "function") for (let key of __getOwnPropNames(from)) !__hasOwnProp.call(to, key) && key !== except && __defProp(to, key, {
        get: () => from[key],
        enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
      });
      return to;
    };
    var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", {
      value: true
    }), mod);
    var index_exports = {};
    __export2(index_exports, {
      timer: () => timer
    });
    module.exports = __toCommonJS(index_exports);
    function timer() {
      let runs = 0;
      const typesOfRuns = /* @__PURE__ */ new Set(), timings = {};
      function print() {
        const typeRuns = runs / typesOfRuns.size;
        let totalTime = 0;
        const out = [`Ran ${typeRuns} per-type, ${runs} total`, ...[...typesOfRuns].map((name) => {
          if (name.endsWith("(ignore)")) return;
          const avg = `avg ${`${timings[name] / typeRuns}`.slice(0, 9).padEnd(9)}ms`, total = timings[name];
          return totalTime += total, `${name.slice(0, 30).padStart(31)} | ${avg} | total ${total}ms`;
        }), `                                    total ${totalTime}ms`].join(`
`);
        return console.info(out), out;
      }
      return {
        start(opts) {
          const quiet = (opts == null ? void 0 : opts.quiet) ?? true;
          function time3(strings, ...vars) {
            const elapsed = performance.now() - start, tag = templateToString(strings, ...vars);
            if (typesOfRuns.add(tag), runs++, timings[tag] ?? (timings[tag] = 0), timings[tag] += elapsed, !quiet) {
              let result = "";
              strings.forEach((str, i) => {
                result += `${str}${i === strings.length - 1 ? "" : vars[i]}`;
              }), console.info(`${`${elapsed}ms`.slice(0, 6).padStart(7)} |`, result);
            }
            start = performance.now();
          }
          let start = performance.now();
          return time3.print = print, time3;
        },
        profile() {
          return {
            timings,
            runs
          };
        },
        print
      };
    }
    function templateToString(strings, ...vars) {
      return strings.reduce((result, str, i) => result + str + (vars[i] !== void 0 ? vars[i] : ""), "");
    }
  }
});

// node_modules/@tamagui/simple-hash/dist/esm/index.mjs
var cache = /* @__PURE__ */ new Map();
var cacheSize = 0;
var simpleHash = (strIn, hashMin = 10) => {
  if (cache.has(strIn)) return cache.get(strIn);
  let str = strIn;
  str[0] === "v" && str.startsWith("var(") && (str = str.slice(6, str.length - 1));
  let hash = 0, valids = "", added = 0;
  const len = str.length;
  for (let i = 0; i < len; i++) {
    if (hashMin !== "strict" && added <= hashMin) {
      const char = str.charCodeAt(i);
      if (char === 46) {
        valids += "--";
        continue;
      }
      if (isValidCSSCharCode(char)) {
        added++, valids += str[i];
        continue;
      }
    }
    hash = hashChar(hash, str[i]);
  }
  const res = valids + (hash ? Math.abs(hash) : "");
  return cacheSize > 1e4 && (cache.clear(), cacheSize = 0), cache.set(strIn, res), cacheSize++, res;
};
var hashChar = (hash, c) => Math.imul(31, hash) + c.charCodeAt(0) | 0;
function isValidCSSCharCode(code) {
  return (
    // A-Z
    code >= 65 && code <= 90 || // a-z
    code >= 97 && code <= 122 || // _
    code === 95 || // -
    code === 45 || // 0-9
    code >= 48 && code <= 57
  );
}

// node_modules/@tamagui/helpers/dist/esm/clamp.mjs
function clamp(value, [min, max]) {
  return Math.min(max, Math.max(min, value));
}

// node_modules/@tamagui/helpers/dist/esm/composeEventHandlers.mjs
function composeEventHandlers(og, next, {
  checkDefaultPrevented = true
} = {}) {
  return !og || !next ? next || og || void 0 : (event) => {
    if (og == null ? void 0 : og(event), !event || !(checkDefaultPrevented && typeof event == "object" && "defaultPrevented" in event) || // @ts-ignore
    "defaultPrevented" in event && !event.defaultPrevented) return next == null ? void 0 : next(event);
  };
}

// node_modules/@tamagui/helpers/dist/esm/concatClassName.mjs
function concatClassName(_cn) {
  const args = arguments, usedPrefixes = [];
  let final = "";
  const len = args.length;
  let propObjects = null;
  for (let x = len; x >= 0; x--) {
    const cns = args[x];
    if (!cns) continue;
    if (!Array.isArray(cns) && typeof cns != "string") {
      propObjects = propObjects || [], propObjects.push(cns);
      continue;
    }
    const names = Array.isArray(cns) ? cns : cns.split(" "), numNames = names.length;
    for (let i = numNames - 1; i >= 0; i--) {
      const name = names[i];
      if (!name || name === " ") continue;
      if (name[0] !== "_") {
        final = name + " " + final;
        continue;
      }
      const splitIndex = name.indexOf("-");
      if (splitIndex < 1) {
        final = name + " " + final;
        continue;
      }
      const isMediaQuery = name[splitIndex + 1] === "_", styleKey = name.slice(1, name.lastIndexOf("-")), mediaKey = isMediaQuery ? name.slice(splitIndex + 2, splitIndex + 7) : null, uid = mediaKey ? styleKey + mediaKey : styleKey;
      if (usedPrefixes.indexOf(uid) > -1) continue;
      usedPrefixes.push(uid);
      const propName = styleKey;
      propName && propObjects && propObjects.some((po) => {
        if (mediaKey) {
          const propKey = pseudoInvert[mediaKey];
          return po && po[propKey] && propName in po[propKey] && po[propKey] !== null;
        }
        return po && propName in po && po[propName] !== null;
      }) || (final = name + " " + final);
    }
  }
  return final;
}
var pseudoInvert = {
  hover: "hoverStyle",
  focus: "focusStyle",
  press: "pressStyle",
  focusVisible: "focusVisibleStyle",
  focusWithin: "focusWithinStyle",
  disabled: "disabledStyle"
};

// node_modules/@tamagui/helpers/dist/esm/types.mjs
var StyleObjectProperty = 0;
var StyleObjectValue = 1;
var StyleObjectIdentifier = 2;
var StyleObjectPseudo = 3;
var StyleObjectRules = 4;

// node_modules/@tamagui/constants/dist/esm/constants.mjs
var import_react = __toESM(require_react(), 1);
var isWeb = true;
var isWindowDefined = typeof window < "u";
var isServer = isWeb && !isWindowDefined;
var isClient = isWeb && isWindowDefined;
var useIsomorphicLayoutEffect = isServer ? import_react.useEffect : import_react.useLayoutEffect;
var isChrome = typeof navigator < "u" && /Chrome/.test(navigator.userAgent || "");
var isWebTouchable = isClient && ("ontouchstart" in window || navigator.maxTouchPoints > 0);
var isTouchable = !isWeb || isWebTouchable;
var isAndroid = false;
var isIos = process.env.TEST_NATIVE_PLATFORM === "ios";
var currentPlatform = "web";

// node_modules/@tamagui/helpers/dist/esm/shouldRenderNativePlatform.mjs
var ALL_PLATFORMS = ["web", "android", "ios"];
function shouldRenderNativePlatform(nativeProp) {
  if (!nativeProp) return null;
  const userRequestedPlatforms = resolvePlatformNames(nativeProp);
  for (const platform of ALL_PLATFORMS) if (platform === currentPlatform && userRequestedPlatforms.has(platform)) return platform;
  return null;
}
function resolvePlatformNames(nativeProp) {
  const platforms = nativeProp === true ? ALL_PLATFORMS : nativeProp === false ? [] : Array.isArray(nativeProp) ? nativeProp : [nativeProp], set = new Set(platforms);
  return set.has("mobile") && (set.add("android"), set.add("ios"), set.delete("mobile")), set;
}

// node_modules/@tamagui/helpers/dist/esm/validStyleProps.mjs
var textColors = {
  color: true,
  textDecorationColor: true,
  textShadowColor: true
};
var tokenCategories = {
  radius: {
    borderRadius: true,
    borderTopLeftRadius: true,
    borderTopRightRadius: true,
    borderBottomLeftRadius: true,
    borderBottomRightRadius: true,
    // logical
    borderStartStartRadius: true,
    borderStartEndRadius: true,
    borderEndStartRadius: true,
    borderEndEndRadius: true
  },
  size: {
    width: true,
    height: true,
    minWidth: true,
    minHeight: true,
    maxWidth: true,
    maxHeight: true,
    blockSize: true,
    minBlockSize: true,
    maxBlockSize: true,
    inlineSize: true,
    minInlineSize: true,
    maxInlineSize: true
  },
  zIndex: {
    zIndex: true
  },
  color: {
    backgroundColor: true,
    borderColor: true,
    borderBlockStartColor: true,
    borderBlockEndColor: true,
    borderBlockColor: true,
    borderBottomColor: true,
    borderInlineColor: true,
    borderInlineStartColor: true,
    borderInlineEndColor: true,
    borderTopColor: true,
    borderLeftColor: true,
    borderRightColor: true,
    borderEndColor: true,
    borderStartColor: true,
    shadowColor: true,
    ...textColors,
    outlineColor: true,
    caretColor: true
  }
};
var stylePropsUnitless = {
  WebkitLineClamp: true,
  animationIterationCount: true,
  aspectRatio: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  columnCount: true,
  flex: true,
  flexGrow: true,
  flexOrder: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  fontWeight: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowGap: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnGap: true,
  gridColumnStart: true,
  gridTemplateColumns: true,
  gridTemplateAreas: true,
  lineClamp: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,
  scale: true,
  scaleX: true,
  scaleY: true,
  scaleZ: true,
  shadowOpacity: true
};
var stylePropsTransform = {
  x: true,
  y: true,
  scale: true,
  perspective: true,
  scaleX: true,
  scaleY: true,
  skewX: true,
  skewY: true,
  matrix: true,
  rotate: true,
  rotateY: true,
  rotateX: true,
  rotateZ: true
};
var stylePropsView = {
  backfaceVisibility: true,
  borderBottomEndRadius: true,
  borderBottomStartRadius: true,
  borderBottomWidth: true,
  borderLeftWidth: true,
  borderRightWidth: true,
  borderBlockWidth: true,
  borderBlockEndWidth: true,
  borderBlockStartWidth: true,
  borderInlineWidth: true,
  borderInlineEndWidth: true,
  borderInlineStartWidth: true,
  borderStyle: true,
  borderBlockStyle: true,
  borderBlockEndStyle: true,
  borderBlockStartStyle: true,
  borderInlineStyle: true,
  borderInlineEndStyle: true,
  borderInlineStartStyle: true,
  borderTopEndRadius: true,
  borderTopStartRadius: true,
  borderTopWidth: true,
  borderWidth: true,
  transform: true,
  transformOrigin: true,
  alignContent: true,
  alignItems: true,
  alignSelf: true,
  borderEndWidth: true,
  borderStartWidth: true,
  bottom: true,
  display: true,
  end: true,
  flexBasis: true,
  flexDirection: true,
  flexWrap: true,
  gap: true,
  columnGap: true,
  rowGap: true,
  justifyContent: true,
  left: true,
  margin: true,
  marginBlock: true,
  marginBlockEnd: true,
  marginBlockStart: true,
  marginInline: true,
  marginInlineStart: true,
  marginInlineEnd: true,
  marginBottom: true,
  marginEnd: true,
  marginHorizontal: true,
  marginLeft: true,
  marginRight: true,
  marginStart: true,
  marginTop: true,
  marginVertical: true,
  overflow: true,
  padding: true,
  paddingBottom: true,
  paddingInline: true,
  paddingBlock: true,
  paddingBlockStart: true,
  paddingInlineEnd: true,
  paddingInlineStart: true,
  paddingEnd: true,
  paddingHorizontal: true,
  paddingLeft: true,
  paddingRight: true,
  paddingStart: true,
  paddingTop: true,
  paddingVertical: true,
  position: true,
  right: true,
  start: true,
  top: true,
  inset: true,
  insetBlock: true,
  insetBlockEnd: true,
  insetBlockStart: true,
  insetInline: true,
  insetInlineEnd: true,
  insetInlineStart: true,
  direction: true,
  shadowOffset: true,
  shadowRadius: true,
  ...tokenCategories.color,
  ...tokenCategories.radius,
  ...tokenCategories.size,
  ...tokenCategories.radius,
  ...stylePropsTransform,
  ...stylePropsUnitless,
  boxShadow: true,
  filter: true,
  // RN doesn't support specific border styles per-edge
  transition: true,
  textWrap: true,
  backdropFilter: true,
  background: true,
  backgroundAttachment: true,
  backgroundBlendMode: true,
  backgroundClip: true,
  backgroundColor: true,
  backgroundImage: true,
  backgroundOrigin: true,
  backgroundPosition: true,
  backgroundRepeat: true,
  backgroundSize: true,
  borderBottomStyle: true,
  borderImage: true,
  borderLeftStyle: true,
  borderRightStyle: true,
  borderTopStyle: true,
  boxSizing: true,
  caretColor: true,
  clipPath: true,
  contain: true,
  containerType: true,
  content: true,
  cursor: true,
  float: true,
  mask: true,
  maskBorder: true,
  maskBorderMode: true,
  maskBorderOutset: true,
  maskBorderRepeat: true,
  maskBorderSlice: true,
  maskBorderSource: true,
  maskBorderWidth: true,
  maskClip: true,
  maskComposite: true,
  maskImage: true,
  maskMode: true,
  maskOrigin: true,
  maskPosition: true,
  maskRepeat: true,
  maskSize: true,
  maskType: true,
  mixBlendMode: true,
  objectFit: true,
  objectPosition: true,
  outlineOffset: true,
  outlineStyle: true,
  outlineWidth: true,
  overflowBlock: true,
  overflowInline: true,
  overflowX: true,
  overflowY: true,
  pointerEvents: true,
  scrollbarWidth: true,
  textEmphasis: true,
  touchAction: true,
  transformStyle: true,
  userSelect: true,
  ...isAndroid ? {
    elevationAndroid: true
  } : {}
};
var stylePropsFont = {
  fontFamily: true,
  fontSize: true,
  fontStyle: true,
  fontWeight: true,
  fontVariant: true,
  letterSpacing: true,
  lineHeight: true,
  textTransform: true
};
var stylePropsTextOnly = {
  ...stylePropsFont,
  textAlign: true,
  textDecorationLine: true,
  textDecorationStyle: true,
  ...textColors,
  textShadowOffset: true,
  textShadowRadius: true,
  userSelect: true,
  selectable: true,
  verticalAlign: true,
  whiteSpace: true,
  wordWrap: true,
  textOverflow: true,
  textDecorationDistance: true,
  cursor: true,
  WebkitLineClamp: true,
  WebkitBoxOrient: true
};
var stylePropsText = {
  ...stylePropsView,
  ...stylePropsTextOnly
};
var stylePropsAll = stylePropsText;
var validPseudoKeys = {
  enterStyle: true,
  exitStyle: true,
  hoverStyle: true,
  pressStyle: true,
  focusStyle: true,
  disabledStyle: true,
  focusWithinStyle: true,
  focusVisibleStyle: true
};
var validStyles = stylePropsView;

// node_modules/@tamagui/helpers/dist/esm/withStaticProperties.mjs
var import_react2 = __toESM(require_react(), 1);
var Decorated = Symbol();
var withStaticProperties = (component, staticProps) => {
  const next = (() => {
    if (component[Decorated]) {
      const _ = import_react2.default.forwardRef((props, ref) => import_react2.default.createElement(component, {
        ...props,
        ref
      }));
      for (const key in component) {
        const v = component[key];
        _[key] = v && typeof v == "object" ? {
          ...v
        } : v;
      }
    }
    return component;
  })();
  return Object.assign(next, staticProps), next[Decorated] = true, next;
};

// node_modules/@tamagui/web/dist/esm/config.mjs
var conf;
var haventCalledErrorMessage = true ? `
Haven't called createTamagui yet.

  This often happens due to having duplicate Tamagui sub-dependencies.

  Tamagui needs every @tamagui/* dependency to be on the exact same version, we include an upgrade script
  with the starter kits that you can call with "yarn upgrade:tamagui" to help with this.

  You may want to clear your node_modules as well and run a fresh install after ugprading.
` : "❌ Error 001";
var getSetting = (key) => {
  if (!conf) throw new Error(haventCalledErrorMessage);
  return conf.settings[key] ?? // @ts-expect-error
  conf[key];
};
var setConfig = (next) => {
  conf = next;
};
var setConfigFont = (name, font, fontParsed) => {
  if (!conf) throw new Error(haventCalledErrorMessage);
  conf.fonts[name] = font, conf.fontsParsed[`$${name}`] = fontParsed;
};
var getConfig = () => {
  if (!conf) throw new Error(true ? "Missing tamagui config, you either have a duplicate config, or haven't set it up. Be sure createTamagui is called before rendering. Also, make sure all of your tamagui dependencies are on the same version (`tamagui`, `@tamagui/package-name`, etc.) not just in your package.json, but in your lockfile." : "Err0");
  return conf;
};
var getConfigMaybe = () => conf;
var tokensMerged;
function setTokens(_) {
  tokensMerged = _;
}
var getTokens = ({
  prefixed
} = {}) => {
  if (!conf) throw new Error(haventCalledErrorMessage);
  const {
    tokens,
    tokensParsed
  } = conf;
  return prefixed === false ? tokens : prefixed === true ? tokensParsed : tokensMerged;
};
var getTokenObject = (value, group) => {
  var _a2, _b;
  return conf.specificTokens[value] ?? (group ? (_a2 = tokensMerged[group]) == null ? void 0 : _a2[value] : (_b = tokensMerged[Object.keys(tokensMerged).find((cat) => tokensMerged[cat][value]) || ""]) == null ? void 0 : _b[value]);
};
var getToken = (value, group, useVariable = isWeb) => {
  const token = getTokenObject(value, group);
  return useVariable ? token == null ? void 0 : token.variable : token == null ? void 0 : token.val;
};
var getTokenValue = (value, group) => {
  if (!(value === "unset" || value === "auto")) return getToken(value, group, false);
};
var getThemes = () => conf.themes;
var configListeners = /* @__PURE__ */ new Set();
var onConfiguredOnce = (cb) => {
  conf ? cb(conf) : configListeners.add(cb);
};
var updateConfig = (key, value) => {
  Object.assign(conf[key], value);
};
var devConfig;
function setupDev(conf22) {
  devConfig = conf22;
}

// node_modules/@tamagui/helpers/dist/esm/index.mjs
var esm_exports = {};
__export(esm_exports, {
  StyleObjectIdentifier: () => StyleObjectIdentifier,
  StyleObjectProperty: () => StyleObjectProperty,
  StyleObjectPseudo: () => StyleObjectPseudo,
  StyleObjectRules: () => StyleObjectRules,
  StyleObjectValue: () => StyleObjectValue,
  clamp: () => clamp,
  composeEventHandlers: () => composeEventHandlers,
  concatClassName: () => concatClassName,
  shouldRenderNativePlatform: () => shouldRenderNativePlatform,
  simpleHash: () => simpleHash,
  stylePropsAll: () => stylePropsAll,
  stylePropsText: () => stylePropsText,
  stylePropsTextOnly: () => stylePropsTextOnly,
  stylePropsTransform: () => stylePropsTransform,
  stylePropsUnitless: () => stylePropsUnitless,
  stylePropsView: () => stylePropsView,
  tokenCategories: () => tokenCategories,
  validPseudoKeys: () => validPseudoKeys,
  validStyles: () => validStyles,
  withStaticProperties: () => withStaticProperties
});

// node_modules/@tamagui/web/dist/esm/createVariable.mjs
function constructCSSVariableName(name) {
  return `var(--${process.env.TAMAGUI_CSS_VARIABLE_PREFIX || ""}${name})`;
}
var createVariable = (props, skipHash = false) => {
  if (!skipHash && isVariable(props)) return props;
  const {
    key,
    name,
    val
  } = props;
  return {
    isVar: true,
    key,
    name: skipHash ? name : simpleHash(name, 40),
    val,
    variable: isWeb ? skipHash ? constructCSSVariableName(name) : createCSSVariable(name) : ""
  };
};
function variableToString(vrble, getValue = false) {
  return isVariable(vrble) ? !getValue && isWeb && vrble.variable ? vrble.variable : `${vrble.val}` : `${vrble || ""}`;
}
function isVariable(v) {
  return v && typeof v == "object" && "isVar" in v;
}
function getVariable(nameOrVariable, group = "size") {
  var _a2;
  if (nameOrVariable == null ? void 0 : nameOrVariable.dynamic) return nameOrVariable;
  if (setDidGetVariableValue(true), isVariable(nameOrVariable)) return variableToString(nameOrVariable);
  const tokens = getConfig().tokensParsed;
  return variableToString(((_a2 = tokens[group]) == null ? void 0 : _a2[nameOrVariable]) ?? nameOrVariable);
}
var accessed = false;
var setDidGetVariableValue = (val) => accessed = val;
var didGetVariableValue = () => accessed;
function getVariableValue(v, group) {
  var _a2;
  if (isVariable(v)) return setDidGetVariableValue(true), v.val;
  if (group) {
    const token = (_a2 = getConfig().tokensParsed[group]) == null ? void 0 : _a2[v];
    if (token) return setDidGetVariableValue(true), token.val;
  }
  return v;
}
function getVariableName(v) {
  return isVariable(v) ? v.name : v;
}
var createCSSVariable = (nameProp, includeVar = true) => {
  if (!nameProp || typeof nameProp != "string") throw new Error(`createCSSVariable expected string, got: ${nameProp}`);
  const name = simpleHash(nameProp, 60);
  return includeVar ? constructCSSVariableName(name) : name;
};

// node_modules/@tamagui/web/dist/esm/helpers/matchMedia.mjs
var matchMedia = typeof window < "u" && window.matchMedia || matchMediaFallback;
function matchMediaFallback(_) {
  return {
    match: (a, b) => false,
    addListener() {
    },
    removeListener() {
    },
    matches: false
  };
}
function setupMatchMedia(_) {
}

// node_modules/@tamagui/web/dist/esm/hooks/useMedia.mjs
var import_react3 = __toESM(require_react(), 1);

// node_modules/@tamagui/web/dist/esm/helpers/pseudoDescriptors.mjs
var pseudoDescriptorsBase = {
  // order of keys here important! in priority order
  hoverStyle: {
    name: "hover",
    priority: 1
  },
  pressStyle: {
    name: "active",
    stateKey: "press",
    priority: 2
  },
  focusVisibleStyle: {
    name: "focus-visible",
    priority: 3,
    stateKey: "focusVisible"
  },
  focusStyle: {
    name: "focus",
    priority: 3
  },
  focusWithinStyle: {
    name: "focus-within",
    priority: 3,
    stateKey: "focusWithin"
  },
  disabledStyle: {
    name: "disabled",
    priority: 4,
    stateKey: "disabled"
  }
};
var pseudoPriorities = {
  hover: 1,
  press: 2,
  focus: 3,
  focusVisible: 3,
  focusWithin: 3,
  disabled: 4
};
var pseudoDescriptors = {
  ...pseudoDescriptorsBase,
  enterStyle: {
    name: "enter",
    selector: ".t_unmounted",
    priority: 4
  },
  exitStyle: {
    name: "exit",
    priority: 5
  }
};

// node_modules/@tamagui/web/dist/esm/hooks/useMedia.mjs
var mediaState = (
  // development only safeguard
  true ? new Proxy({}, {
    get(target, key) {
      if (typeof key == "string" && key[0] === "$" && // dont error on $$typeof
      key[1] !== "$") throw new Error(`Access mediaState should not use "$": ${key}`);
      return Reflect.get(target, key);
    }
  }) : {}
);
var mediaQueryConfig = {};
var getMedia = () => mediaState;
var mediaKeys = /* @__PURE__ */ new Set();
var mediaKeyRegex = /\$(platform|theme|group)-/;
var isMediaKey = (key) => {
  if (mediaKeys.has(key)) return true;
  if (key[0] === "$") {
    const match = key.match(mediaKeyRegex);
    if (match) return match[1];
  }
  return false;
};
var initState;
var defaultMediaImportance = Object.keys(pseudoDescriptors).length;
var mediaKeysOrdered;
var getMediaKeyImportance = (key) => {
  if (key[0] === "$") throw new Error("use short key");
  return getConfig().settings.mediaPropOrder ? defaultMediaImportance : mediaKeysOrdered.indexOf(key) + 100;
};
var dispose = /* @__PURE__ */ new Set();
var mediaVersion = 0;
var configureMedia = (config) => {
  const {
    media
  } = config, mediaQueryDefaultActive = getSetting("mediaQueryDefaultActive");
  if (media) {
    mediaVersion++;
    for (const key in media) mediaState[key] = (mediaQueryDefaultActive == null ? void 0 : mediaQueryDefaultActive[key]) || false, mediaKeys.add(`$${key}`);
    Object.assign(mediaQueryConfig, media), initState = {
      ...mediaState
    }, mediaKeysOrdered = Object.keys(media), setupMediaListeners();
  }
};
function unlisten() {
  dispose.forEach((cb) => cb()), dispose.clear();
}
var setupVersion = -1;
function setupMediaListeners() {
  if (!(isWeb && isServer) && !process.env.IS_STATIC && setupVersion !== mediaVersion) {
    setupVersion = mediaVersion, unlisten();
    for (const key in mediaQueryConfig) {
      let update = function() {
        const next = !!getMatch().matches;
        next !== mediaState[key] && (mediaState = {
          ...mediaState,
          [key]: next
        }, updateMediaListeners());
      };
      const str = mediaObjectToString(mediaQueryConfig[key], key), getMatch = () => matchMedia(str), match = getMatch();
      if (!match) throw new Error("⚠️ No match");
      match.addListener(update), dispose.add(() => {
        match.removeListener(update);
      }), update();
    }
  }
}
var listeners = /* @__PURE__ */ new Set();
function updateMediaListeners() {
  listeners.forEach((cb) => cb(mediaState));
}
var States = /* @__PURE__ */ new WeakMap();
function setMediaShouldUpdate(ref, enabled, keys) {
  const cur = States.get(ref);
  (!cur || cur.enabled !== enabled || keys) && States.set(ref, {
    ...cur,
    enabled,
    keys
  });
}
function subscribe(subscriber) {
  return listeners.add(subscriber), () => {
    listeners.delete(subscriber);
  };
}
function useMedia(cc, debug) {
  const componentState = cc ? States.get(cc) : null, internalRef = (0, import_react3.useRef)();
  internalRef.current || (internalRef.current = {
    keys: /* @__PURE__ */ new Set()
  });
  const {
    keys,
    lastState = getSetting("disableSSR") ? mediaState : initState
  } = internalRef.current;
  keys.size && keys.clear();
  const state = (0, import_react3.useSyncExternalStore)(subscribe, () => {
    if (componentState == null ? void 0 : componentState.enabled) return internalRef.current.lastState = mediaState, mediaState;
    const curKeys2 = (componentState == null ? void 0 : componentState.keys) || keys;
    if (!curKeys2.size) return lastState;
    for (const key of curKeys2) if (mediaState[key] !== lastState[key]) return debug && console.warn("useMedia() ✍️", key, lastState[key], "=>", mediaState[key]), internalRef.current.lastState = mediaState, mediaState;
    return lastState;
  }, getServerSnapshot);
  return new Proxy(state, {
    get(_, key) {
      return !disableMediaTouch && typeof key == "string" && keys.add(key), Reflect.get(state, key);
    }
  });
}
var getServerSnapshot = () => initState;
var disableMediaTouch = false;
function _disableMediaTouch(val) {
  disableMediaTouch = val;
}
function getMediaState(mediaGroups, layout) {
  disableMediaTouch = true;
  let res;
  try {
    res = Object.fromEntries([...mediaGroups].map((mediaKey) => [mediaKey, mediaKeyMatch(mediaKey, layout)]));
  } finally {
    disableMediaTouch = false;
  }
  return res;
}
var getMediaImportanceIfMoreImportant = (mediaKey, key, importancesUsed, isSizeMedia) => {
  const importance = isSizeMedia && !getSetting("mediaPropOrder") ? getMediaKeyImportance(mediaKey) : defaultMediaImportance;
  return !importancesUsed[key] || importance > importancesUsed[key] ? importance : null;
};
function camelToHyphen(str) {
  return str.replace(/[A-Z]/g, (m) => `-${m.toLowerCase()}`).toLowerCase();
}
var cache2 = /* @__PURE__ */ new WeakMap();
var cachedMediaKeyToQuery = {};
function mediaObjectToString(query, key) {
  if (typeof query == "string") return query;
  if (cache2.has(query)) return cache2.get(query);
  const res = Object.entries(query).map(([feature, value]) => (feature = camelToHyphen(feature), typeof value == "string" ? `(${feature}: ${value})` : (typeof value == "number" && /[height|width]$/.test(feature) && (value = `${value}px`), `(${feature}: ${value})`))).join(" and ");
  return key && (cachedMediaKeyToQuery[key] = res), cache2.set(query, res), res;
}
function mediaKeyMatch(key, dimensions) {
  const mediaQueries = mediaQueryConfig[key];
  return Object.keys(mediaQueries).every((query) => {
    const expectedVal = +mediaQueries[query], isMax = query.startsWith("max"), isWidth = query.endsWith("Width"), givenVal = dimensions[isWidth ? "width" : "height"];
    return isMax ? givenVal < expectedVal : givenVal > expectedVal;
  });
}

// node_modules/@tamagui/compose-refs/dist/esm/compose-refs.mjs
var React2 = __toESM(require_react(), 1);
function setRef(ref, value) {
  typeof ref == "function" ? ref(value) : ref && (ref.current = value);
}
function composeRefs(...refs) {
  return (node2) => refs.forEach((ref) => setRef(ref, node2));
}
function useComposedRefs(...refs) {
  return React2.useCallback(composeRefs(...refs), refs);
}

// node_modules/@tamagui/web/dist/esm/helpers/createStyledContext.mjs
var import_react4 = __toESM(require_react(), 1);

// node_modules/@tamagui/web/dist/esm/helpers/objectIdentityKey.mjs
function objectIdentityKey(obj) {
  let k = "";
  for (const key in obj) {
    k += key;
    const arg = obj[key];
    let type = typeof arg;
    if (!arg || type !== "object" && type !== "function") k += type + arg;
    else if (cache3.has(arg)) k += cache3.get(arg);
    else {
      let v = Math.random();
      cache3.set(arg, v), k += v;
    }
  }
  return k;
}
var cache3 = /* @__PURE__ */ new WeakMap();

// node_modules/@tamagui/web/dist/esm/helpers/createStyledContext.mjs
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var createReactContext = import_react4.default[Math.random(), "createContext"];
function createStyledContext(defaultValues) {
  const OGContext = createReactContext(defaultValues), OGProvider = OGContext.Provider, Context = OGContext, scopedContexts = /* @__PURE__ */ new Map();
  function getOrCreateScopedContext(scope) {
    let ScopedContext = scopedContexts.get(scope);
    return ScopedContext || (ScopedContext = createReactContext(defaultValues), scopedContexts.set(scope, ScopedContext)), ScopedContext;
  }
  const Provider = ({
    children,
    scope,
    ...values
  }) => {
    const next = import_react4.default.useMemo(() => ({
      // this ! is a workaround for ts error
      ...defaultValues,
      ...values
    }), [objectIdentityKey(values)]);
    let Provider2 = OGProvider;
    return scope && (Provider2 = getOrCreateScopedContext(scope).Provider), (0, import_jsx_runtime.jsx)(Provider2, {
      value: next,
      children
    });
  }, useStyledContext = (scope) => {
    const context = scope ? getOrCreateScopedContext(scope) : OGContext;
    return import_react4.default.useContext(context);
  };
  return Context.Provider = Provider, Context.props = defaultValues, Context.context = OGContext, Context.useStyledContext = useStyledContext, Context;
}

// node_modules/@tamagui/web/dist/esm/contexts/ComponentContext.mjs
var ComponentContext = createStyledContext({
  disableSSR: void 0,
  inText: false,
  language: null,
  animationDriver: null,
  setParentFocusState: null,
  groups: {
    emit: null,
    subscribe: null,
    state: {}
  }
});

// node_modules/@tamagui/web/dist/esm/helpers/defaultOffset.mjs
var defaultOffset = {
  height: 0,
  width: 0
};

// node_modules/@tamagui/normalize-css-color/dist/esm/index.mjs
var normalizeColor = __toESM(require_normalize_color(), 1);
var norm = normalizeColor.default || normalizeColor;
var normalizeCSSColor = norm;
function rgba(colorInt) {
  const r = Math.round((colorInt & 4278190080) >>> 24), g = Math.round((colorInt & 16711680) >>> 16), b = Math.round((colorInt & 65280) >>> 8), a = ((colorInt & 255) >>> 0) / 255;
  return {
    r,
    g,
    b,
    a
  };
}

// node_modules/@tamagui/web/dist/esm/helpers/normalizeColor.mjs
var normalizeColor2 = (color, opacity) => {
  if (color) {
    if (color[0] === "$") return color;
    if (color.startsWith("var(")) {
      if (typeof opacity == "number" && opacity < 1) return `color-mix(in srgb, ${color} ${opacity * 100}%, transparent)`;
    } else {
      const rgba3 = getRgba(color);
      if (rgba3) {
        const colors = `${rgba3.r},${rgba3.g},${rgba3.b}`;
        return opacity === 1 ? `rgb(${colors})` : `rgba(${colors},${opacity ?? rgba3.a ?? 1})`;
      }
    }
    return color;
  }
};
var getRgba = (color) => {
  const colorNum = normalizeCSSColor(color);
  if (colorNum != null) return rgba(colorNum);
};

// node_modules/@tamagui/web/dist/esm/helpers/normalizeValueWithProperty.mjs
var stylePropsAllPlusTransforms = {
  ...stylePropsAll,
  translateX: true,
  translateY: true
};
function normalizeValueWithProperty(value, property = "") {
  if (!isWeb || stylePropsUnitless[property] || property && !stylePropsAllPlusTransforms[property] || typeof value == "boolean") return value;
  let res = value;
  return value && typeof value == "object" ? value : (typeof value == "number" ? res = `${value}px` : property && (res = `${res}`), res);
}

// node_modules/@tamagui/web/dist/esm/helpers/transformsToString.mjs
function transformsToString(transforms) {
  return transforms.map(
    // { scale: 2 } => 'scale(2)'
    // { translateX: 20 } => 'translateX(20px)'
    // { matrix: [1,2,3,4,5,6] } => 'matrix(1,2,3,4,5,6)'
    // { perspective: 1000 } => perspective(1000px)
    (transform) => {
      const type = Object.keys(transform)[0], value = transform[type];
      return type === "matrix" || type === "matrix3d" ? `${type}(${value.join(",")})` : `${type}(${normalizeValueWithProperty(value, type)})`;
    }
  ).join(" ");
}

// node_modules/@tamagui/web/dist/esm/helpers/getCSSStylesAtomic.mjs
function getCSSStylesAtomic(style) {
  styleToCSS(style);
  const out = [];
  for (const key in style) {
    if (key === "$$css") continue;
    const val = style[key];
    if (key in pseudoDescriptors) val && out.push(...getStyleAtomic(val, pseudoDescriptors[key]));
    else if (isMediaKey(key)) for (const subKey in val) {
      const so = getStyleObject(val, subKey);
      so && (so[0] = key, out.push(so));
    }
    else {
      const so = getStyleObject(style, key);
      so && out.push(so);
    }
  }
  return out;
}
var getStyleAtomic = (style, pseudo) => {
  styleToCSS(style);
  const out = [];
  for (const key in style) {
    const so = getStyleObject(style, key, pseudo);
    so && out.push(so);
  }
  return out;
};
var conf2 = null;
var getStyleObject = (style, key, pseudo) => {
  let val = style[key];
  if (val == null) return;
  key === "transform" && Array.isArray(style.transform) && (val = transformsToString(val));
  const value = normalizeValueWithProperty(val, key), hash = simpleHash(typeof value == "string" ? value : `${value}`), pseudoPrefix = pseudo ? `0${pseudo.name}-` : "";
  conf2 || (conf2 = getConfigMaybe());
  const identifier = `_${(conf2 == null ? void 0 : conf2.inverseShorthands[key]) || key}-${pseudoPrefix}${hash}`, rules = createAtomicRules(identifier, key, value, pseudo);
  return [
    // array for performance
    key,
    value,
    identifier,
    pseudo == null ? void 0 : pseudo.name,
    rules
  ];
};
function styleToCSS(style) {
  const {
    shadowOffset,
    shadowRadius,
    shadowColor,
    shadowOpacity
  } = style;
  if (shadowRadius || shadowColor) {
    const offset = shadowOffset || defaultOffset, width = normalizeValueWithProperty(offset.width), height = normalizeValueWithProperty(offset.height), radius = normalizeValueWithProperty(shadowRadius), color = normalizeColor2(shadowColor, shadowOpacity), shadow = `${width} ${height} ${radius} ${color}`;
    style.boxShadow = style.boxShadow ? `${style.boxShadow}, ${shadow}` : shadow, delete style.shadowOffset, delete style.shadowRadius, delete style.shadowColor, delete style.shadowOpacity;
  }
  const {
    textShadowColor,
    textShadowOffset,
    textShadowRadius
  } = style;
  if (textShadowColor || textShadowOffset || textShadowRadius) {
    const {
      height,
      width
    } = textShadowOffset || defaultOffset, radius = textShadowRadius || 0, color = normalizeValueWithProperty(textShadowColor, "textShadowColor");
    if (color && (height !== 0 || width !== 0 || radius !== 0)) {
      const blurRadius = normalizeValueWithProperty(radius), offsetX = normalizeValueWithProperty(width), offsetY = normalizeValueWithProperty(height);
      style.textShadow = `${offsetX} ${offsetY} ${blurRadius} ${color}`;
    }
    delete style.textShadowColor, delete style.textShadowOffset, delete style.textShadowRadius;
  }
}
function createDeclarationBlock(style, important = false) {
  let next = "";
  for (const [key, value] of style) next += `${hyphenateStyleName(key)}:${value}${important ? " !important" : ""};`;
  return `{${next}}`;
}
var hcache = {};
var toHyphenLower = (match) => `-${match.toLowerCase()}`;
var hyphenateStyleName = (key) => {
  if (key in hcache) return hcache[key];
  const val = key.replace(/[A-Z]/g, toHyphenLower);
  return hcache[key] = val, val;
};
var selectorPriority = (() => {
  const res = {};
  for (const key in pseudoDescriptors) {
    const pseudo = pseudoDescriptors[key];
    res[pseudo.name] = `${[...Array(pseudo.priority)].map(() => ":root").join("")} `;
  }
  return res;
})();
function createAtomicRules(identifier, property, value, pseudo) {
  const pseudoIdPostfix = pseudo ? pseudo.name === "disabled" ? "[aria-disabled]" : `:${pseudo.name}` : "", pseudoSelector = pseudo == null ? void 0 : pseudo.selector;
  let selector = pseudo ? pseudoSelector ? `${pseudoSelector} .${identifier}` : `${selectorPriority[pseudo.name]} .${identifier}${pseudoIdPostfix}` : `:root .${identifier}`;
  pseudoSelector === pseudoDescriptors.enterStyle.selector && (selector = `${selector}, .${identifier}${pseudoSelector}`);
  const important = !!pseudo;
  let rules = [];
  switch (property) {
    // Equivalent to using '::placeholder'
    case "placeholderTextColor": {
      const block = createDeclarationBlock([["color", value], ["opacity", 1]], important);
      rules.push(`${selector}::placeholder${block}`);
      break;
    }
    // all webkit prefixed rules
    case "backgroundClip":
    case "userSelect": {
      const webkitProperty = `Webkit${`${property[0].toUpperCase()}${property.slice(1)}`}`, block = createDeclarationBlock([[property, value], [webkitProperty, value]], important);
      rules.push(`${selector}${block}`);
      break;
    }
    // Polyfill for additional 'pointer-events' values
    case "pointerEvents": {
      let finalValue = value;
      value === "auto" || value === "box-only" ? (finalValue = "auto", value === "box-only" && rules.push(`${selector}>*${boxOnly}`)) : (value === "none" || value === "box-none") && (finalValue = "none", value === "box-none" && rules.push(`${selector}>*${boxNone}`));
      const block = createDeclarationBlock([["pointerEvents", finalValue]], true);
      rules.push(`${selector}${block}`);
      break;
    }
    default: {
      const block = createDeclarationBlock([[property, value]], important);
      rules.push(`${selector}${block}`);
      break;
    }
  }
  return (pseudo == null ? void 0 : pseudo.name) === "hover" && (rules = rules.map((r) => `@media (hover) {${r}}`)), rules;
}
var boxNone = createDeclarationBlock([["pointerEvents", "auto"]], true);
var boxOnly = createDeclarationBlock([["pointerEvents", "none"]], true);

// node_modules/@tamagui/web/dist/esm/hooks/useTheme.mjs
var import_react6 = __toESM(require_react(), 1);

// node_modules/@tamagui/web/dist/esm/hooks/getThemeProxied.mjs
var cache4 = /* @__PURE__ */ new Map();
var curKeys;
var curProps;
var curState;
var emptyObject = {};
function getThemeProxied(_props, _state, _keys) {
  if (!(_state == null ? void 0 : _state.theme)) return emptyObject;
  if (curKeys = _keys, curProps = _props, curState = _state, cache4.has(curState.theme)) return cache4.get(curState.theme);
  const config = getConfig();
  function track2(key) {
    curKeys && (curKeys.current || (curKeys.current = /* @__PURE__ */ new Set()), curKeys.current.add(key), curProps.debug && console.info(` 🎨 useTheme() tracking new key: ${key}`, curKeys));
  }
  const proxied = Object.fromEntries(Object.entries(_state.theme).flatMap(([key, value]) => {
    const proxied2 = {
      ...value,
      get val() {
        return globalThis.tamaguiAvoidTracking || track2(key), value.val;
      },
      get(platform) {
        if (!curState) return;
        const outVal = getVariable(value), {
          name,
          scheme,
          inverses
        } = curState;
        return outVal;
      }
    };
    return [[key, proxied2], [`$${key}`, proxied2]];
  }));
  return cache4.set(_state.theme, proxied), proxied;
}

// node_modules/@tamagui/web/dist/esm/hooks/useThemeState.mjs
var import_react5 = __toESM(require_react(), 1);
var ThemeStateContext = (0, import_react5.createContext)("");
var allListeners = /* @__PURE__ */ new Map();
var listenersByParent = {};
var HasRenderedOnce = /* @__PURE__ */ new WeakMap();
var HadTheme = /* @__PURE__ */ new WeakMap();
var PendingUpdate = /* @__PURE__ */ new Map();
var states = /* @__PURE__ */ new Map();
var localStates = /* @__PURE__ */ new Map();
var shouldForce = false;
var forceUpdateThemes = () => {
  cacheVersion++, shouldForce = true, allListeners.forEach((cb) => cb());
};
var getThemeState = (id) => states.get(id);
var cacheVersion = 0;
var themes = null;
var rootThemeState = null;
var useThemeState = (props, isRoot = false, keys) => {
  const {
    disable
  } = props, parentId = (0, import_react5.useContext)(ThemeStateContext);
  if (!parentId && !isRoot) throw new Error("No parent?");
  if (disable) return states.get(parentId) || {
    id: "",
    name: "light",
    theme: getConfig().themes.light,
    inverses: 0
  };
  const id = (0, import_react5.useId)(), subscribe3 = (0, import_react5.useCallback)((cb) => (listenersByParent[parentId] || (listenersByParent[parentId] = /* @__PURE__ */ new Set()), listenersByParent[parentId].add(id), allListeners.set(id, () => {
    PendingUpdate.set(id, shouldForce ? "force" : true), cb();
  }), () => {
    allListeners.delete(id), listenersByParent[parentId].delete(id), localStates.delete(id), states.delete(id), PendingUpdate.delete(id);
  }), [id, parentId]), propsKey = getPropsKey(props), getSnapshot = () => {
    var _a2, _b;
    let local = localStates.get(id);
    const needsUpdate = isRoot || props.name === "light" || props.name === "dark" || props.name === null ? true : HasRenderedOnce.get(keys) ? ((_a2 = keys == null ? void 0 : keys.current) == null ? void 0 : _a2.size) ? true : (_b = props.needsUpdate) == null ? void 0 : _b.call(props) : true, [rerender, next] = getNextState(local, props, propsKey, isRoot, id, parentId, needsUpdate, PendingUpdate.get(id));
    return PendingUpdate.delete(id), (!local || rerender) && (local = {
      ...next
    }, localStates.set(id, local)), props.debug && props.debug !== "profile" && (console.groupCollapsed(` ${id} 🪄 ${rerender}`, local.name, ">", next.name), console.info({
      props,
      propsKey,
      isRoot,
      parentId,
      local,
      next,
      needsUpdate
    }), console.groupEnd()), Object.assign(local, next), local.id = id, states.set(id, next), local;
  };
  globalThis.time && globalThis.time`theme-prep-uses`;
  const state = (0, import_react5.useSyncExternalStore)(subscribe3, getSnapshot, getSnapshot);
  return useIsomorphicLayoutEffect(() => {
    var _a2;
    if (!HasRenderedOnce.get(keys)) {
      HasRenderedOnce.set(keys, true);
      return;
    }
    if (!propsKey) {
      HadTheme.get(keys) && scheduleUpdate(id), HadTheme.set(keys, false);
      return;
    }
    props.debug && props.debug !== "profile" && console.warn(` · useTheme(${id}) scheduleUpdate`, propsKey, (_a2 = states.get(id)) == null ? void 0 : _a2.name), scheduleUpdate(id), HadTheme.set(keys, true);
  }, [keys, propsKey]), state;
};
var getNextState = (lastState, props, propsKey, isRoot = false, id, parentId, needsUpdate, pendingUpdate) => {
  const {
    debug
  } = props, parentState = states.get(parentId);
  themes || (themes = getConfig().themes);
  const name = !propsKey && (!lastState || !(lastState == null ? void 0 : lastState.isNew)) ? null : getNewThemeName(parentState == null ? void 0 : parentState.name, props, pendingUpdate === "force" ? true : !!needsUpdate), isSameAsParent = parentState && (!name || name === parentState.name), shouldRerender = !!(needsUpdate && (pendingUpdate || (lastState == null ? void 0 : lastState.name) !== (parentState == null ? void 0 : parentState.name)));
  if (debug && debug !== "profile") {
    const message = ` · useTheme(${id}) => ${name} needsUpdate ${needsUpdate} shouldRerender ${shouldRerender}`;
    console.groupCollapsed(message), console.trace({
      name,
      lastState,
      parentState,
      props,
      propsKey,
      id,
      isSameAsParent
    }), console.groupEnd();
  }
  if (isSameAsParent) return [shouldRerender, {
    ...parentState,
    isNew: false
  }];
  if (!name) {
    const next = lastState ?? parentState;
    if (!next) throw new Error("No theme and no parent?");
    return shouldRerender ? [true, {
      ...parentState || lastState
    }] : [false, next];
  }
  const scheme = getScheme(name), parentInverses = (parentState == null ? void 0 : parentState.inverses) ?? 0, isInverse = parentState && scheme !== parentState.scheme, inverses = parentInverses + (isInverse ? 1 : 0), nextState = {
    id,
    name,
    theme: themes[name],
    scheme,
    parentId,
    parentName: parentState == null ? void 0 : parentState.name,
    inverses,
    isInverse,
    isNew: true
  };
  if (isRoot && (rootThemeState = nextState), pendingUpdate !== "force" && lastState && lastState.name === name) return [false, nextState];
  const shouldAvoidRerender = pendingUpdate !== "force" && lastState && !needsUpdate && nextState.name === lastState.name;
  return debug && debug !== "profile" && (console.groupCollapsed(` · useTheme(${id}) ⏭️ ${name} shouldAvoidRerender: ${shouldAvoidRerender}`), console.info({
    lastState,
    needsUpdate,
    nextState,
    pendingUpdate
  }), console.groupEnd()), shouldAvoidRerender ? [false, nextState] : [true, nextState];
};
function scheduleUpdate(id) {
  const queue = [id], visited = /* @__PURE__ */ new Set();
  for (; queue.length; ) {
    const parent = queue.shift(), children = listenersByParent[parent];
    if (children) for (const childId of children) visited.has(childId) || (visited.add(childId), queue.push(childId));
  }
  visited.forEach((childId) => {
    var _a2;
    (_a2 = allListeners.get(childId)) == null ? void 0 : _a2();
  });
}
var validSchemes = {
  light: "light",
  dark: "dark"
};
function getScheme(name) {
  return validSchemes[name.split("_")[0]];
}
function getNewThemeName(parentName = "", {
  name,
  reset,
  componentName,
  inverse,
  debug
}, forceUpdate = false) {
  if (name && reset) throw new Error(false ? "❌004" : "Cannot reset and set a new name at the same time.");
  if (reset) {
    if (!parentName) throw new Error("‼️");
    const lastPartIndex = parentName.lastIndexOf("_");
    return lastPartIndex <= 0 ? parentName : parentName.slice(lastPartIndex);
  }
  const {
    themes: themes2
  } = getConfig(), parentParts = parentName.split("_"), lastName = parentParts[parentParts.length - 1];
  lastName && lastName[0].toLowerCase() !== lastName[0] && parentParts.pop();
  const subNames = [name && componentName ? `${name}_${componentName}` : void 0, name, componentName].filter(Boolean);
  let found = null;
  const max = parentParts.length;
  for (let i = 0; i <= max; i++) {
    const base = (i === 0 ? parentParts : parentParts.slice(0, -i)).join("_");
    for (const subName of subNames) {
      const potential = base ? `${base}_${subName}` : subName;
      if (potential in themes2) {
        found = potential;
        break;
      }
    }
    if (found) break;
  }
  if (inverse) {
    found || (found = parentName);
    const scheme = found.split("_")[0];
    found = found.replace(new RegExp(`^${scheme}`), scheme === "light" ? "dark" : "light");
  }
  return !forceUpdate && found === parentName && // if its a scheme only sub-theme, we always consider it "new" because it likely inverses
  // and we want to avoid reparenting
  !validSchemes[found] ? null : found;
}
var getPropsKey = ({
  name,
  reset,
  inverse,
  forceClassName,
  componentName
}) => `${name || ""}${inverse || ""}${reset || ""}${forceClassName || ""}${componentName || ""}`;
var hasThemeUpdatingProps = (props) => "inverse" in props || "name" in props || "reset" in props || "forceClassName" in props;

// node_modules/@tamagui/web/dist/esm/hooks/useTheme.mjs
var useTheme = (props = {}) => {
  const [theme] = useThemeWithState(props);
  return theme;
};
var useThemeWithState = (props, isRoot = false) => {
  const keys = (0, import_react6.useRef)(null), themeState = useThemeState(props, isRoot, keys);
  return (themeState == null ? void 0 : themeState.theme) || process.env.TAMAGUI_DISABLE_NO_THEME_WARNING !== "1" && console.error(`[tamagui] No theme found, this could be due to an invalid theme name (given theme props ${JSON.stringify(props)}).

If this is intended and you are using Tamagui without any themes, you can disable this warning by setting the environment variable TAMAGUI_DISABLE_NO_THEME_WARNING=1`), [getThemeProxied(props, themeState, keys), themeState];
};

// node_modules/@tamagui/use-did-finish-ssr/dist/esm/index.mjs
var React4 = __toESM(require_react(), 1);
function useDidFinishSSR(value) {
  return React4.useSyncExternalStore(subscribe2, () => value ?? true, () => false);
}
var subscribe2 = () => () => {
};

// node_modules/@tamagui/web/dist/esm/views/Theme.mjs
var import_react8 = __toESM(require_react(), 1);

// node_modules/@tamagui/web/dist/esm/views/ThemeDebug.mjs
var import_react7 = __toESM(require_react(), 1);
var import_react_dom = __toESM(require_react_dom(), 1);
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
var node;
function ThemeDebug({
  themeState,
  themeProps,
  children
}) {
  if (true) {
    const isHydrated = useDidFinishSSR();
    if (typeof document < "u" && (node || (node = document.createElement("div"), node.style.height = "200px", node.style.overflowY = "scroll", node.style.position = "fixed", node.style.zIndex = 1e7, node.style.bottom = "30px", node.style.left = "30px", node.style.right = "30px", node.style.display = "flex", node.style.border = "1px solid #888", node.style.flexDirection = "row", node.style.background = "var(--background)")), (0, import_react7.useEffect)(() => {
      document.body.appendChild(node);
    }, []), themeProps["disable-child-theme"] || !isHydrated) return children;
    const parentState = themeState.parentId ? getThemeState(themeState.parentId) : null;
    return (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, {
      children: [(0, import_react_dom.createPortal)((0, import_jsx_runtime2.jsxs)("code", {
        style: {
          whiteSpace: "pre",
          maxWidth: 250,
          overflow: "auto",
          padding: 5
        },
        children: ["<Theme ", themeState.id, " /> ", JSON.stringify({
          name: themeState.name,
          color1: themeState.theme.color1.val,
          parentId: themeState.parentId,
          inverses: themeState.inverses,
          isNew: themeState.isNew,
          themeProps: {
            name: themeProps.name,
            componentName: themeProps.componentName,
            reset: themeProps.reset,
            inverse: themeProps.inverse
          },
          parentState: {
            name: parentState == null ? void 0 : parentState.name,
            isNew: parentState == null ? void 0 : parentState.isNew
          }
        }, null, 2)]
      }), node), (0, import_jsx_runtime2.jsx)("div", {
        style: {
          color: "red"
        },
        children: themeState.id
      }), children]
    });
  }
  return children;
}
ThemeDebug.displayName = "ThemeDebug";

// node_modules/@tamagui/web/dist/esm/views/Theme.mjs
var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);
var empty = {
  className: "",
  style: {}
};
var Theme = (0, import_react8.forwardRef)(function(props, ref) {
  if (props.disable) return props.children;
  const isRoot = !!props._isRoot, [_, themeState] = useThemeWithState(props, isRoot);
  let finalChildren = props["disable-child-theme"] ? import_react8.Children.map(props.children, (child) => (0, import_react8.cloneElement)(child, {
    "data-disable-theme": true
  })) : props.children;
  if (ref) try {
    import_react8.default.Children.only(finalChildren), finalChildren = (0, import_react8.cloneElement)(finalChildren, {
      ref
    });
  } catch {
  }
  const stateRef = (0, import_react8.useRef)({
    hasEverThemed: false
  });
  return getThemedChildren(themeState, finalChildren, props, isRoot, stateRef);
});
Theme.avoidForwardRef = true;
function getThemedChildren(themeState, children, props, isRoot = false, stateRef) {
  const {
    shallow,
    forceClassName
  } = props, state = stateRef.current;
  let shouldRenderChildrenWithTheme = state.hasEverThemed || themeState.isNew || isRoot || hasThemeUpdatingProps(props);
  if (props.debug === "visualize" && (children = (0, import_jsx_runtime3.jsx)(ThemeDebug, {
    themeState,
    themeProps: props,
    children
  })), !shouldRenderChildrenWithTheme) return children;
  children = (0, import_jsx_runtime3.jsx)(ThemeStateContext.Provider, {
    value: themeState.id,
    children
  });
  const {
    isInverse,
    name
  } = themeState, requiresExtraWrapper = isInverse || forceClassName;
  if (state.hasEverThemed || (state.hasEverThemed = true), (requiresExtraWrapper || // if the theme is exactly dark or light, its likely to change between dark/light
  // and that would require wrapping which would re-parent, so to avoid re-parenting do this
  themeState.name === "dark" || themeState.name === "light") && (state.hasEverThemed = "wrapped"), shallow && themeState.parentId) {
    const parentState = getThemeState(themeState.isNew ? themeState.id : themeState.parentId);
    if (!parentState) throw new Error("‼️010");
    children = import_react8.Children.toArray(children).map((child) => (0, import_react8.isValidElement)(child) ? (0, import_react8.cloneElement)(child, void 0, (0, import_jsx_runtime3.jsx)(Theme, {
      name: parentState.name,
      children: child.props.children
    })) : child);
  }
  if (props.debug && console.warn(" getThemedChildren", {
    requiresExtraWrapper,
    forceClassName,
    themeState,
    state,
    ...getThemeClassNameAndStyle(themeState, props, isRoot)
  }), forceClassName === false) return children;
  if (isWeb) {
    const {
      className,
      style
    } = getThemeClassNameAndStyle(themeState, props, isRoot);
    if (children = (0, import_jsx_runtime3.jsx)("span", {
      ...{
        "data-theme-id": themeState.id
      },
      className: `${className} _dsp_contents is_Theme`,
      style,
      children
    }), state.hasEverThemed === "wrapped") {
      const className2 = requiresExtraWrapper ? `${isInverse ? name.startsWith("light") ? "t_light is_inversed" : name.startsWith("dark") ? "t_dark is_inversed" : "" : ""} _dsp_contents` : "_dsp_contents";
      children = (0, import_jsx_runtime3.jsx)("span", {
        className: className2,
        children
      });
    }
    return children;
  }
  return children;
}
function getThemeClassNameAndStyle(themeState, props, isRoot = false) {
  if (!themeState.isNew && !props.forceClassName) return empty;
  const themeColor = (themeState == null ? void 0 : themeState.theme) && themeState.isNew ? variableToString(themeState.theme.color) : "", style = themeColor ? {
    color: themeColor
  } : void 0, maxInverses = getSetting("maxDarkLightNesting") || 3, themeClassName = themeState.inverses >= maxInverses ? themeState.name : themeState.name.replace(schemePrefix, ""), className = `${isRoot ? "" : "t_sub_theme"} t_${themeClassName}`;
  return {
    style,
    className
  };
}
var schemePrefix = /^(dark|light)_/;

// node_modules/@tamagui/web/dist/esm/helpers/themeable.mjs
var import_react9 = __toESM(require_react(), 1);
var import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);
function themeable(Component, staticConfig, optimize = false) {
  const withTheme = import_react9.default.forwardRef(function(props, ref) {
    const {
      themeInverse,
      theme,
      componentName,
      themeReset,
      ...rest
    } = props;
    let overriddenContextProps;
    const context = staticConfig == null ? void 0 : staticConfig.context;
    if (context) for (const key in context.props) {
      const val = props[key];
      val !== void 0 && (overriddenContextProps || (overriddenContextProps = {}), overriddenContextProps[key] = val);
    }
    const element = (
      // @ts-expect-error its ok
      (0, import_jsx_runtime4.jsx)(Component, {
        ref,
        ...rest,
        "data-disable-theme": true
      })
    );
    let filteredProps = null;
    const compName = componentName || (staticConfig == null ? void 0 : staticConfig.componentName);
    if (compName && (filteredProps || (filteredProps = {}), filteredProps.componentName = compName), "debug" in props && (filteredProps || (filteredProps = {}), filteredProps.debug = props.debug), "theme" in props && (filteredProps || (filteredProps = {}), filteredProps.name = props.theme), "themeInverse" in props && (filteredProps || (filteredProps = {}), filteredProps.inverse = props.themeInverse), "themeReset" in props && (filteredProps || (filteredProps = {}), filteredProps.reset = themeReset), optimize && !filteredProps) return element;
    let contents = (0, import_jsx_runtime4.jsx)(Theme, {
      "disable-child-theme": true,
      ...filteredProps,
      children: element
    });
    if (context) {
      const Provider = context.Provider, contextValue = import_react9.default.useContext(context);
      contents = (0, import_jsx_runtime4.jsx)(Provider, {
        ...contextValue,
        ...overriddenContextProps,
        children: contents
      });
    }
    return contents;
  });
  return withTheme.displayName = `Themed(${(Component == null ? void 0 : Component.displayName) || (Component == null ? void 0 : Component.name) || "Anonymous"})`, withTheme;
}

// node_modules/@tamagui/web/dist/esm/createComponent.mjs
var import_react14 = __toESM(require_react(), 1);

// node_modules/@tamagui/web/dist/esm/constants/constants.mjs
var THEME_CLASSNAME_PREFIX = "t_";
var FONT_DATA_ATTRIBUTE_NAME = "data-tamagui-font";
var stackDefaultStyles = {};
var webViewFlexCompatStyles = {
  display: "flex",
  alignItems: "stretch",
  flexDirection: "column",
  flexBasis: "auto",
  // @ts-expect-error
  boxSizing: "border-box",
  position: process.env.TAMAGUI_POSITION_STATIC === "1" ? "static" : "relative",
  minHeight: 0,
  minWidth: 0,
  flexShrink: 0
};
Object.assign(stackDefaultStyles, webViewFlexCompatStyles);

// node_modules/@tamagui/web/dist/esm/constants/isDevTools.mjs
var isDevTools = (() => {
  if (true) try {
    return new Function("try {return this===window;}catch(e){ return false;}")();
  } catch {
  }
  return false;
})();

// node_modules/@tamagui/web/dist/esm/defaultComponentState.mjs
var defaultComponentState = {
  hover: false,
  press: false,
  pressIn: false,
  focus: false,
  focusVisible: false,
  focusWithin: false,
  unmounted: true,
  disabled: false
};
var defaultComponentStateMounted = {
  ...defaultComponentState,
  unmounted: false
};
var defaultComponentStateShouldEnter = {
  ...defaultComponentState,
  unmounted: "should-enter"
};

// node_modules/@tamagui/web/dist/esm/helpers/consoleLog.mjs
var groupEnd = console.groupEnd.bind(console);
var gc = console.groupCollapsed.bind(console);
var groupCollapsed = isWeb ? gc : console.info;

// node_modules/@tamagui/web/dist/esm/helpers/getShorthandValue.mjs
var inverseShorthands = null;
var getShorthandValue = (props, key) => (inverseShorthands || (inverseShorthands = getConfig().inverseShorthands), props[key] ?? (inverseShorthands ? props[inverseShorthands[key]] : void 0));

// node_modules/@tamagui/web/dist/esm/helpers/getSplitStyles.mjs
var import_react10 = __toESM(require_react(), 1);

// node_modules/@tamagui/web/dist/esm/constants/accessibilityDirectMap.mjs
var accessibilityDirectMap = {};
{
  const items = {
    Hidden: true,
    ActiveDescendant: true,
    Atomic: true,
    AutoComplete: true,
    Busy: true,
    Checked: true,
    ColumnCount: "colcount",
    ColumnIndex: "colindex",
    ColumnSpan: "colspan",
    Current: true,
    Details: true,
    ErrorMessage: true,
    Expanded: true,
    HasPopup: true,
    Invalid: true,
    Label: true,
    Level: true,
    Modal: true,
    Multiline: true,
    MultiSelectable: true,
    Orientation: true,
    Owns: true,
    Placeholder: true,
    PosInSet: true,
    Pressed: true,
    RoleDescription: true,
    RowCount: true,
    RowIndex: true,
    RowSpan: true,
    Selected: true,
    SetSize: true,
    Sort: true,
    ValueMax: true,
    ValueMin: true,
    ValueNow: true,
    ValueText: true
  };
  for (const key in items) {
    let val = items[key];
    val === true && (val = key.toLowerCase()), accessibilityDirectMap[`accessibility${key}`] = `aria-${val}`;
  }
}

// node_modules/@tamagui/web/dist/esm/helpers/getGroupPropParts.mjs
function getGroupPropParts(groupProp) {
  const mediaQueries = getMedia(), [_, name, part3, part4] = groupProp.split("-");
  let pseudo;
  const media = part3 in mediaQueries ? part3 : void 0;
  return media ? pseudo = part4 : pseudo = part3, {
    name,
    pseudo,
    media
  };
}

// node_modules/@tamagui/web/dist/esm/helpers/createMediaStyle.mjs
var MEDIA_SEP = "_";
var prefixes = null;
var selectors = null;
var groupPseudoToPseudoCSSMap = {
  press: "active",
  focusVisible: "focus-visible",
  focusWithin: "focus-within"
};
var specificities = new Array(5).fill(0).map((_, i) => new Array(i).fill(":root").join(""));
function getThemeOrGroupSelector(name, styleInner, isGroup, groupParts, isTheme = false, precedenceImportancePrefix = "") {
  const selectorStart = styleInner.lastIndexOf(":root") + 5, selectorEnd = styleInner.lastIndexOf("{"), selector = styleInner.slice(selectorStart, selectorEnd), precedenceSpace = getSetting("themeClassNameOnRoot") && isTheme ? "" : " ", pseudoSelectorName = groupParts.pseudo ? groupPseudoToPseudoCSSMap[groupParts.pseudo] || groupParts.pseudo : void 0, pseudoSelector = pseudoSelectorName ? `:${pseudoSelectorName}` : "", presedencePrefix = `:root${precedenceImportancePrefix}${precedenceSpace}`, mediaSelector = `.t_${isGroup ? "group_" : ""}${name}${pseudoSelector}`;
  return [selector, `${presedencePrefix}${mediaSelector} ${selector.replaceAll(":root", "")}`];
}
var createMediaStyle = (styleObject, mediaKeyIn, mediaQueries, type, negate, priority) => {
  const [propertyIn, , identifier, pseudoIn, rules] = styleObject;
  let property = propertyIn;
  const enableMediaPropOrder = getSetting("mediaPropOrder"), isTheme = type === "theme", isPlatform = type === "platform", isGroup = type === "group", isNonWindowMedia = isTheme || isPlatform || isGroup, negKey = negate ? "0" : "", ogPrefix = identifier.slice(0, identifier.indexOf("-") + 1), id = `${ogPrefix}${MEDIA_SEP}${mediaKeyIn.replace("-", "")}${negKey}${MEDIA_SEP}`;
  let styleRule = "", groupPriority = "", groupMediaKey, containerName, nextIdentifier = identifier.replace(ogPrefix, id), styleInner = rules.map((rule) => rule.replace(identifier, nextIdentifier)).join(";"), isHover = false;
  if (isNonWindowMedia) {
    let specificity = (priority || 0) + (isGroup || isPlatform ? 1 : 0);
    if (isTheme || isGroup) {
      const groupParts = getGroupPropParts(isTheme ? "theme-" + mediaKeyIn : mediaKeyIn), {
        name,
        media,
        pseudo
      } = groupParts;
      groupMediaKey = media, isGroup && (containerName = name), (pseudo === "press" || pseudoIn === "active") && (specificity += 2), pseudo === "hover" && (isHover = true);
      const [selector, nextSelector] = getThemeOrGroupSelector(name, styleInner, isGroup, groupParts, isTheme, specificities[specificity]);
      styleRule = styleInner.replace(selector, nextSelector);
    } else styleRule = `${specificities[specificity]}${styleInner}`;
  }
  if (!isNonWindowMedia || groupMediaKey) {
    if (!selectors) {
      const mediaKeys2 = Object.keys(mediaQueries);
      selectors = Object.fromEntries(mediaKeys2.map((key) => [key, mediaObjectToString(mediaQueries[key])])), enableMediaPropOrder || (prefixes = Object.fromEntries(mediaKeys2.map((k, index) => [k, new Array(index + 1).fill(":root").join("")])));
    }
    const mediaKey = groupMediaKey || mediaKeyIn, mediaSelector = selectors[mediaKey], mediaQuery = `${negate ? "not all and " : ""}${mediaSelector}`, precedenceImportancePrefix = groupMediaKey ? groupPriority : enableMediaPropOrder && priority ? (
      // this new array should be cached
      specificities[priority]
    ) : (
      // @ts-ignore
      prefixes[mediaKey]
    ), prefix = groupMediaKey ? `@container ${containerName}` : "@media";
    groupMediaKey && (styleInner = styleRule), styleInner.includes(prefix) ? styleRule = styleInner.replace("{", ` and ${mediaQuery} {`).replace("and screen and", "and") : styleRule = `${prefix} ${mediaQuery}{${precedenceImportancePrefix}${styleInner}}`, groupMediaKey && (styleRule = `@supports (contain: ${getSetting("webContainerType") || "inline-size"}) {${styleRule}}`);
  }
  return isHover && (styleRule = `@media (hover:hover){${styleRule}}`), [property, void 0, nextIdentifier, void 0, [styleRule]];
};

// node_modules/@tamagui/web/dist/esm/helpers/normalizeShadow.mjs
function normalizeShadow({
  shadowColor,
  shadowOffset,
  shadowOpacity,
  shadowRadius
}) {
  var _a2;
  const {
    height,
    width
  } = shadowOffset || defaultOffset;
  return {
    shadowOffset: {
      width: width || 0,
      height: height || 0
    },
    shadowRadius: shadowRadius || 0,
    shadowColor: normalizeColor2(shadowColor, 1),
    shadowOpacity: shadowOpacity ?? (shadowColor ? (_a2 = getRgba(shadowColor)) == null ? void 0 : _a2.a : 1)
  };
}

// node_modules/@tamagui/web/dist/esm/helpers/expandStyles.mjs
function fixStyles(style) {
  var _a2;
  (style.shadowRadius != null || style.shadowColor || style.shadowOpacity != null || style.shadowOffset) && Object.assign(style, normalizeShadow(style));
  for (const key in borderDefaults) key in style && (style[_a2 = borderDefaults[key]] || (style[_a2] = "solid"));
}
var nativeStyle = isWeb ? null : "borderStyle";
var borderDefaults = {
  borderWidth: "borderStyle",
  borderBottomWidth: nativeStyle || "borderBottomStyle",
  borderTopWidth: nativeStyle || "borderTopStyle",
  borderLeftWidth: nativeStyle || "borderLeftStyle",
  borderRightWidth: nativeStyle || "borderRightStyle"
  // TODO: need to add borderBlock and borderInline here, but they are alot and might impact performance
};

// node_modules/@tamagui/web/dist/esm/helpers/insertStyleRule.mjs
var scannedCache = /* @__PURE__ */ new WeakMap();
var totalSelectorsInserted = /* @__PURE__ */ new Map();
var allSelectors = {};
var allRules = {};
var insertedTransforms = {};
var getAllSelectors = () => allSelectors;
var getAllRules = () => Object.values(allRules);
var getAllTransforms = () => insertedTransforms;
function addTransform(identifier, css, rule) {
  const s = css.indexOf("transform:");
  if (s === -1) {
    console.error(`❌ Invalid transform, likely used deg/% improperly ${identifier}`);
    return;
  }
  const startI = s + 10, endI = css.indexOf(";"), value = css.slice(startI, endI);
  if (!insertedTransforms[identifier]) return insertedTransforms[identifier] = value, true;
}
function listenForSheetChanges() {
  if (!isClient) return;
  new MutationObserver((entries) => {
    for (const entry of entries) if (entry instanceof HTMLStyleElement && entry.sheet || entry instanceof HTMLLinkElement && entry.href.endsWith(".css")) {
      scanAllSheets();
      break;
    }
  }).observe(document.head, {
    childList: true
  });
}
var lastScannedSheets = null;
function scanAllSheets(collectThemes = false, tokens) {
  if (!isClient) return;
  let themes2;
  const sheets = document.styleSheets || [], prev = lastScannedSheets, current = new Set(sheets);
  for (const sheet2 of current) if (sheet2) {
    const out = updateSheetStyles(sheet2, false, collectThemes, tokens);
    out && (themes2 = out);
  }
  if (lastScannedSheets = current, prev) for (const sheet2 of prev) sheet2 && !current.has(sheet2) && updateSheetStyles(sheet2, true);
  return themes2;
}
function track(id, remove = false) {
  const next = (totalSelectorsInserted.get(id) || 0) + (remove ? -1 : 1);
  return totalSelectorsInserted.set(id, next), next;
}
var bailAfterEnv = process.env.TAMAGUI_BAIL_AFTER_SCANNING_X_CSS_RULES;
var bailAfter = bailAfterEnv ? +bailAfterEnv : 700;
function updateSheetStyles(sheet2, remove = false, collectThemes = false, tokens) {
  var _a2, _b;
  let rules;
  try {
    if (rules = sheet2.cssRules, !rules) return;
  } catch {
    return;
  }
  const firstSelector = (_a2 = getTamaguiSelector(rules[0], collectThemes)) == null ? void 0 : _a2[0], lastSelector = (_b = getTamaguiSelector(rules[rules.length - 1], collectThemes)) == null ? void 0 : _b[0], cacheKey = `${rules.length}${firstSelector}${lastSelector}`, lastScanned = scannedCache.get(sheet2);
  if (!remove && lastScanned === cacheKey) return;
  const len = rules.length;
  let fails = 0, dedupedThemes;
  const nameToTheme = {};
  for (let i = 0; i < len; i++) {
    const rule = rules[i];
    if (!(rule instanceof CSSStyleRule)) continue;
    const response = getTamaguiSelector(rule, collectThemes);
    if (response) fails = 0;
    else {
      if (fails++, fails > bailAfter) return;
      continue;
    }
    const [identifier, cssRule, isTheme] = response;
    if (isTheme) {
      const deduped = addThemesFromCSS(cssRule, tokens);
      if (deduped) {
        for (const name of deduped.names) nameToTheme[name] ? (Object.apply(nameToTheme[name], deduped.theme), deduped.names = deduped.names.filter((x) => x !== name)) : nameToTheme[name] = deduped.theme;
        dedupedThemes || (dedupedThemes = []), dedupedThemes.push(deduped);
      }
      continue;
    }
    if (!process.env.TAMAGUI_REACT_19) {
      const total = track(identifier, remove);
      remove ? total === 0 && delete allSelectors[identifier] : identifier in allSelectors || (!identifier.startsWith("_transform-") || addTransform(identifier, cssRule.cssText, cssRule)) && (allSelectors[identifier] = cssRule.cssText);
    }
  }
  return scannedCache.set(sheet2, cacheKey), dedupedThemes;
}
var colorVarToVal;
var rootComputedStyle = null;
function addThemesFromCSS(cssStyleRule, tokens) {
  const selectors2 = cssStyleRule.selectorText.split(",");
  if (!selectors2.length) return;
  if ((tokens == null ? void 0 : tokens.color) && !colorVarToVal) {
    colorVarToVal = {};
    for (const key in tokens.color) {
      const token = tokens.color[key];
      colorVarToVal[token.name] = token.val;
    }
  }
  const rules = (cssStyleRule.cssText || "").slice(cssStyleRule.selectorText.length + 2, -1).split(";"), values = {};
  for (const rule of rules) {
    const sepI = rule.indexOf(":");
    if (sepI === -1) continue;
    const varIndex = rule.indexOf("--");
    let key = rule.slice(varIndex === -1 ? 0 : varIndex + 2, sepI);
    process.env.TAMAGUI_CSS_VARIABLE_PREFIX && (key = key.replace(process.env.TAMAGUI_CSS_VARIABLE_PREFIX, ""));
    const val = rule.slice(sepI + 2);
    let value;
    if (val[0] === "v" && val.startsWith("var(")) {
      const varName = val.slice(6, -1), tokenVal = colorVarToVal[varName];
      tokenVal ? value = tokenVal : (rootComputedStyle || (rootComputedStyle = getComputedStyle(document.body)), value = rootComputedStyle.getPropertyValue("--" + varName));
    } else value = val;
    values[key] = createVariable({
      key,
      name: key,
      val: value
    }, true);
  }
  const names = /* @__PURE__ */ new Set();
  for (const selector of selectors2) {
    if (selector === " .tm_xxt") continue;
    const lastThemeSelectorIndex = selector.lastIndexOf(".t_"), name = selector.slice(lastThemeSelectorIndex).slice(3), [schemeChar] = selector[lastThemeSelectorIndex - 5], scheme = schemeChar === "d" ? "dark" : schemeChar === "i" ? "light" : "", themeName = scheme && scheme !== name ? `${scheme}_${name}` : name;
    !themeName || themeName === "light_dark" || themeName === "dark_light" || names.add(themeName);
  }
  return {
    names: [...names],
    theme: values
  };
}
var tamaguiSelectorRegex = /\.tm_xxt/;
function getTamaguiSelector(rule, collectThemes = false) {
  if (rule instanceof CSSStyleRule) {
    const text = rule.selectorText;
    if (text[0] === ":" && text[1] === "r" && tamaguiSelectorRegex.test(text)) {
      const id = getIdentifierFromTamaguiSelector(
        // next.js minifies it so its in front
        text.replace(tamaguiSelectorRegex, "")
      );
      return collectThemes ? [id, rule, true] : [id, rule];
    }
  } else if (rule instanceof CSSMediaRule) return rule.cssRules.length > 1 ? void 0 : getTamaguiSelector(rule.cssRules[0]);
}
var getIdentifierFromTamaguiSelector = (selector) => {
  const dotIndex = selector.indexOf(":");
  return dotIndex > -1 ? selector.slice(7, dotIndex) : selector.slice(7);
};
var sheet = null;
function updateRules(identifier, rules) {
  if (!process.env.TAMAGUI_REACT_19) return identifier in allRules ? false : (allRules[identifier] = rules.join(" "), identifier.startsWith("_transform-") ? addTransform(identifier, rules[0]) : true);
}
var nonce = "";
function insertStyleRules(rulesToInsert) {
  if (!process.env.TAMAGUI_REACT_19) {
    if (!sheet && isClient && document.head) {
      const styleTag = document.createElement("style");
      nonce && (styleTag.nonce = nonce), sheet = document.head.appendChild(styleTag).sheet;
    }
    if (!sheet) return;
    for (const key in rulesToInsert) {
      const styleObject = rulesToInsert[key], identifier = styleObject[StyleObjectIdentifier];
      if (!shouldInsertStyleRules(identifier)) continue;
      const rules = styleObject[StyleObjectRules];
      allSelectors[identifier] = rules.join(`
`), track(identifier), updateRules(identifier, rules);
      for (const rule of rules) if (false) try {
        sheet.insertRule(rule, sheet.cssRules.length);
      } catch (err) {
        console.error("Error inserting CSS", err);
      }
      else sheet.insertRule(rule, sheet.cssRules.length);
    }
  }
}
var minInsertAmt = process.env.TAMAGUI_INSERT_SELECTOR_TRIES ? +process.env.TAMAGUI_INSERT_SELECTOR_TRIES : 1;
function shouldInsertStyleRules(identifier) {
  if (process.env.TAMAGUI_REACT_19) return true;
  {
    if (process.env.IS_STATIC === "is_static") return true;
    const total = totalSelectorsInserted.get(identifier);
    return totalSelectorsInserted.size > +(process.env.TAMAGUI_STYLE_INSERTION_WARNING_LIMIT || 1e4) && console.warn('Warning: inserting many CSS rules, you may be animating something and generating many CSS insertions, which can degrade performance. Instead, try using the "disableClassName" property on elements that change styles often. To disable this warning set TAMAGUI_STYLE_INSERTION_WARNING_LIMIT from 50000 to something higher'), total === void 0 || total < minInsertAmt;
  }
}

// node_modules/@tamagui/web/dist/esm/helpers/isActivePlatform.mjs
function isActivePlatform(key) {
  if (!key.startsWith("$platform")) return true;
  const platform = key.slice(10);
  return (
    // web, ios, android
    platform === currentPlatform || // web, native
    platform === "web"
  );
}

// node_modules/@tamagui/web/dist/esm/helpers/isActiveTheme.mjs
function isActiveTheme(key, activeThemeName) {
  if (key.startsWith("$theme-")) return key.slice(7).startsWith(activeThemeName);
}

// node_modules/@tamagui/web/dist/esm/helpers/log.mjs
function log(...args) {
  if (true) {
    _disableMediaTouch(true);
    try {
      return console.info(...args);
    } catch (err) {
      console.error(err);
    } finally {
      _disableMediaTouch(false);
    }
  }
}

// node_modules/@tamagui/web/dist/esm/constants/webToNativeProps.mjs
var webToNativeDynamicExpansion = {};
var webToNativeExpansion = {};

// node_modules/@tamagui/web/dist/esm/helpers/expandStyle.mjs
var neg1Flex = [["flexGrow", 0], ["flexShrink", 1], ["flexBasis", "auto"]];
function expandStyle(key, value) {
  if (key === "flex") return value === -1 ? neg1Flex : [["flexGrow", value], ["flexShrink", 1], ["flexBasis", getSetting("styleCompat") === "react-native" ? 0 : "auto"]];
  switch (key) {
    case "textAlignVertical":
      return [["verticalAlign", value === "center" ? "middle" : value]];
    case "writingDirection":
      return [["direction", value]];
  }
  if (key in EXPANSIONS) return EXPANSIONS[key].map((key2) => [key2, value]);
  if (key in webToNativeExpansion) return webToNativeExpansion[key].map((key2) => [key2, value]);
  if (key in webToNativeDynamicExpansion) return webToNativeDynamicExpansion[key](value);
}
var all = ["Top", "Right", "Bottom", "Left"];
var horiz = ["Right", "Left"];
var vert = ["Top", "Bottom"];
var xy = ["X", "Y"];
var EXPANSIONS = {
  borderColor: ["TopColor", "RightColor", "BottomColor", "LeftColor"],
  borderRadius: ["TopLeftRadius", "TopRightRadius", "BottomRightRadius", "BottomLeftRadius"],
  borderWidth: ["TopWidth", "RightWidth", "BottomWidth", "LeftWidth"],
  margin: all,
  marginHorizontal: horiz,
  marginVertical: vert,
  overscrollBehavior: xy,
  padding: all,
  paddingHorizontal: horiz,
  paddingVertical: vert,
  ...isWeb && {
    // react-native only supports borderStyle
    borderStyle: ["TopStyle", "RightStyle", "BottomStyle", "LeftStyle"],
    // react-native doesn't support X / Y
    overflow: xy
  }
};
var _a;
for (const parent in EXPANSIONS) {
  const prefix = parent.slice(0, ((_a = /[A-Z]/.exec(parent)) == null ? void 0 : _a.index) ?? parent.length);
  EXPANSIONS[parent] = EXPANSIONS[parent].map((k) => `${prefix}${k}`);
}

// node_modules/@tamagui/web/dist/esm/helpers/getVariantExtras.mjs
var cache5 = /* @__PURE__ */ new WeakMap();
var getVariantExtras = (styleState) => {
  if (cache5.has(styleState)) return cache5.get(styleState);
  const {
    props,
    conf: conf4,
    context,
    theme
  } = styleState;
  let fonts = conf4.fontsParsed;
  (context == null ? void 0 : context.language) && (fonts = getFontsForLanguage(conf4.fontsParsed, context.language));
  const next = {
    fonts,
    tokens: conf4.tokensParsed,
    theme,
    get fontFamily() {
      return getVariableValue(styleState.fontFamily || styleState.props.fontFamily) || props.fontFamily || getVariableValue(styleState.conf.defaultFont);
    },
    get font() {
      return fonts[this.fontFamily] || (!props.fontFamily || props.fontFamily[0] === "$" ? fonts[styleState.conf.defaultFont] : void 0);
    },
    props
  };
  return cache5.set(styleState, next), next;
};
var fontLanguageCache = /* @__PURE__ */ new WeakMap();
function getFontsForLanguage(fonts, language) {
  if (fontLanguageCache.has(language)) return fontLanguageCache.get(language);
  const next = {
    ...fonts,
    ...Object.fromEntries(Object.entries(language).map(([name, lang]) => {
      if (lang === "default") return [];
      const langKey = `$${name}_${lang}`;
      return [`$${name}`, fonts[langKey]];
    }))
  };
  return fontLanguageCache.set(language, next), next;
}

// node_modules/@tamagui/web/dist/esm/helpers/isObj.mjs
var isObj = (x) => x && !Array.isArray(x) && typeof x == "object";

// node_modules/@tamagui/web/dist/esm/helpers/normalizeStyle.mjs
function normalizeStyle(style, disableNormalize = false) {
  const res = {};
  for (let key in style) {
    const prop = style[key];
    if (prop == null) continue;
    if (key in pseudoDescriptors || // this should capture all parent-based styles like media, group, etc
    key[0] === "$" && isObj(prop)) {
      res[key] = normalizeStyle(prop, disableNormalize);
      continue;
    }
    const value = disableNormalize ? prop : normalizeValueWithProperty(prop, key), out = expandStyle(key, value);
    out ? Object.assign(res, Object.fromEntries(out)) : res[key] = value;
  }
  return fixStyles(res), res;
}

// node_modules/@tamagui/web/dist/esm/helpers/skipProps.mjs
var skipProps = {
  untilMeasured: 1,
  animation: 1,
  space: 1,
  animateOnly: 1,
  disableClassName: 1,
  debug: 1,
  componentName: 1,
  disableOptimization: 1,
  tag: 1,
  style: 1,
  // handled after loop so pseudos set usedKeys and override it if necessary
  group: 1,
  themeInverse: 1,
  animatePresence: 1
};
Object.assign(skipProps, {
  ellipsizeMode: 1,
  accessibilityElementsHidden: 1,
  accessibilityIgnoresInvertColors: 1,
  accessibilityLanguage: 1,
  adjustsFontSizeToFit: 1,
  allowFontScaling: 1,
  dataDetectorType: 1,
  dynamicTypeRamp: 1,
  elevationAndroid: 1,
  hapticFeedback: 1,
  hapticStyle: 1,
  hitSlop: 1,
  onAccessibilityAction: 1,
  importantForAccessibility: 1,
  lineBreakStrategyIOS: 1,
  maxFontSizeMultiplier: 1,
  minimumFontScale: 1,
  needsOffscreenAlphaCompositing: 1,
  nextFocusDown: 1,
  nextFocusForward: 1,
  nextFocusLeft: 1,
  nextFocusRight: 1,
  nextFocusUp: 1,
  onMagicTap: 1,
  selectionColor: 1,
  shouldRasterizeIOS: 1,
  suppressHighlighting: 1,
  textBreakStrategy: 1
});

// node_modules/@tamagui/web/dist/esm/helpers/propMapper.mjs
var propMapper = (key, value, styleState, disabled, map) => {
  var _a2;
  if (disabled) return map(key, value);
  if (lastFontFamilyToken = null, key === "elevationAndroid") return;
  const {
    conf: conf4,
    styleProps,
    staticConfig
  } = styleState;
  if (value === "unset") {
    const unsetVal = (_a2 = conf4.unset) == null ? void 0 : _a2[key];
    if (unsetVal != null) value = unsetVal;
    else return;
  }
  const {
    variants
  } = staticConfig;
  if (!styleProps.noExpand && variants && key in variants) {
    const variantValue = resolveVariants(key, value, styleProps, styleState, "");
    if (variantValue) {
      variantValue.forEach(([key2, value2]) => map(key2, value2));
      return;
    }
  }
  if (styleProps.disableExpandShorthands || key in conf4.shorthands && (key = conf4.shorthands[key]), value != null && (value[0] === "$" ? value = getTokenForKey(key, value, styleProps, styleState) : isVariable(value) && (value = resolveVariableValue(key, value, styleProps.resolveValues))), value != null) {
    key === "fontFamily" && lastFontFamilyToken && (styleState.fontFamily = lastFontFamilyToken);
    const expanded = styleProps.noExpand ? null : expandStyle(key, value);
    if (expanded) {
      const max = expanded.length;
      for (let i = 0; i < max; i++) {
        const [nkey, nvalue] = expanded[i];
        map(nkey, nvalue);
      }
    } else map(key, value);
  }
};
var resolveVariants = (key, value, styleProps, styleState, parentVariantKey) => {
  const {
    staticConfig,
    conf: conf4,
    debug
  } = styleState, {
    variants
  } = staticConfig;
  if (!variants) return;
  let variantValue = getVariantDefinition(variants[key], value, conf4);
  if (debug === "verbose" && (console.groupCollapsed(`♦️♦️♦️ resolve variant ${key}`), console.info({
    key,
    value,
    variantValue,
    variants
  }), console.groupEnd()), !variantValue) {
    if (process.env.TAMAGUI_WARN_ON_MISSING_VARIANT === "1" && typeof value != "boolean") {
      const name = staticConfig.componentName || "[UnnamedComponent]";
      console.warn(`No variant found: ${name} has variant "${key}", but no matching value "${value}"`);
    }
    return;
  }
  if (typeof variantValue == "function") {
    const fn = variantValue, extras = getVariantExtras(styleState);
    variantValue = fn(value, extras), debug === "verbose" && (console.groupCollapsed("   expanded functional variant", key), console.info({
      fn,
      variantValue,
      extras
    }), console.groupEnd());
  }
  let fontFamilyResult;
  if (isObj(variantValue)) {
    const fontFamilyUpdate = variantValue.fontFamily || variantValue[conf4.inverseShorthands.fontFamily];
    fontFamilyUpdate && (fontFamilyResult = getFontFamilyFromNameOrVariable(fontFamilyUpdate, conf4), styleState.fontFamily = fontFamilyResult, debug === "verbose" && console.info("   updating font family", fontFamilyResult)), variantValue = resolveTokensAndVariants(key, variantValue, styleProps, styleState, parentVariantKey);
  }
  if (variantValue) {
    const expanded = normalizeStyle(variantValue, !!styleProps.noNormalize);
    debug === "verbose" && console.info("   expanding styles from ", variantValue, "to", expanded);
    const next = Object.entries(expanded);
    return fontFamilyResult && fontFamilyResult[0] === "$" && (lastFontFamilyToken = getVariableValue(fontFamilyResult)), next;
  }
};
function getFontFamilyFromNameOrVariable(input, conf4) {
  if (isVariable(input)) {
    const val = variableToFontNameCache.get(input);
    if (val) return val;
    for (const key in conf4.fontsParsed) {
      const familyVariable = conf4.fontsParsed[key].family;
      if (isVariable(familyVariable) && (variableToFontNameCache.set(familyVariable, key), familyVariable === input)) return key;
    }
  } else if (typeof input == "string" && input[0] === "$") return input;
}
var variableToFontNameCache = /* @__PURE__ */ new WeakMap();
var resolveTokensAndVariants = (key, value, styleProps, styleState, parentVariantKey) => {
  var _a2;
  const {
    conf: conf4,
    staticConfig,
    debug,
    theme
  } = styleState, {
    variants
  } = staticConfig, res = {};
  debug === "verbose" && console.info("   - resolveTokensAndVariants", key, value);
  for (const _key in value) {
    const subKey = conf4.shorthands[_key] || _key, val = value[_key];
    if (!(!styleProps.noSkip && subKey in skipProps)) {
      if (styleProps.noExpand) res[subKey] = val;
      else if (variants && subKey in variants) {
        if (parentVariantKey && parentVariantKey === key) res[subKey] = // SYNC WITH *1
        val[0] === "$" ? getTokenForKey(subKey, val, styleProps, styleState) : val;
        else {
          const variantOut = resolveVariants(subKey, val, styleProps, styleState, key);
          if (variantOut) for (const [key2, val2] of variantOut) val2 != null && (key2 in pseudoDescriptors ? (res[key2] ?? (res[key2] = {}), Object.assign(res[key2], val2)) : res[key2] = val2);
        }
        continue;
      }
      if (isVariable(val)) {
        res[subKey] = resolveVariableValue(subKey, val, styleProps.resolveValues), debug === "verbose" && console.info("variable", subKey, res[subKey]);
        continue;
      }
      if (typeof val == "string") {
        const fVal = (
          // SYNC WITH *1
          val[0] === "$" ? getTokenForKey(subKey, val, styleProps, styleState) : val
        );
        res[subKey] = fVal;
        continue;
      }
      if (isObj(val)) {
        const subObject = resolveTokensAndVariants(subKey, val, styleProps, styleState, key);
        debug === "verbose" && console.info("object", subKey, subObject), res[subKey] ?? (res[subKey] = {}), Object.assign(res[subKey], subObject);
      } else res[subKey] = val;
      debug && ((_a2 = res[subKey]) == null ? void 0 : _a2[0]) === "$" && console.warn(`⚠️ Missing token in theme ${theme.name}:`, subKey, res[subKey], theme);
    }
  }
  return res;
};
var tokenCats = ["size", "color", "radius", "space", "zIndex"].map((name) => ({
  name,
  spreadName: `...${name}`
}));
function getVariantDefinition(variant, value, conf4) {
  if (!variant) return;
  if (typeof variant == "function") return variant;
  const exact = variant[value];
  if (exact) return exact;
  if (value != null) {
    const {
      tokensParsed
    } = conf4;
    for (const {
      name,
      spreadName
    } of tokenCats) if (spreadName in variant && value in tokensParsed[name]) return variant[spreadName];
    const fontSizeVariant = variant["...fontSize"];
    if (fontSizeVariant && conf4.fontSizeTokens.has(value)) return fontSizeVariant;
  }
  return variant[`:${typeof value}`] || variant["..."];
}
var fontShorthand = {
  fontSize: "size",
  fontWeight: "weight"
};
var lastFontFamilyToken = null;
var getTokenForKey = (key, value, styleProps, styleState) => {
  var _a2, _b, _c, _d;
  let resolveAs = styleProps.resolveValues || "none";
  if (resolveAs === "none") return value;
  const {
    theme,
    conf: conf4 = getConfig(),
    context,
    fontFamily,
    staticConfig
  } = styleState, themeValue = theme ? theme[value] || theme[value.slice(1)] : void 0, tokensParsed = conf4.tokensParsed;
  let valOrVar, hasSet = false;
  const customTokenAccept = (_a2 = staticConfig == null ? void 0 : staticConfig.accept) == null ? void 0 : _a2[key];
  if (customTokenAccept) {
    const val = themeValue ?? tokensParsed[customTokenAccept][value];
    val != null && (resolveAs = "value", valOrVar = val, hasSet = true);
  }
  if (themeValue) {
    if (resolveAs === "except-theme") return value;
    valOrVar = themeValue, styleState.debug === "verbose" && (globalThis.tamaguiAvoidTracking = true, console.info(` - resolving ${key} to theme value ${value} resolveAs ${resolveAs}`, valOrVar), globalThis.tamaguiAvoidTracking = false), hasSet = true;
  } else {
    if (value in conf4.specificTokens) hasSet = true, valOrVar = conf4.specificTokens[value];
    else {
      switch (key) {
        case "fontFamily": {
          valOrVar = ((_b = ((context == null ? void 0 : context.language) ? getFontsForLanguage(conf4.fontsParsed, context.language) : conf4.fontsParsed)[value]) == null ? void 0 : _b.family) || value, lastFontFamilyToken = value, hasSet = true;
          break;
        }
        case "fontSize":
        case "lineHeight":
        case "letterSpacing":
        case "fontWeight": {
          const fam = fontFamily || conf4.defaultFontToken;
          if (fam) {
            const fontsParsed = (context == null ? void 0 : context.language) ? getFontsForLanguage(conf4.fontsParsed, context.language) : conf4.fontsParsed;
            valOrVar = ((_d = (_c = fontsParsed[fam] || fontsParsed[conf4.defaultFontToken]) == null ? void 0 : _c[fontShorthand[key] || key]) == null ? void 0 : _d[value]) || value, hasSet = true;
          }
          break;
        }
      }
      for (const cat in tokenCategories) if (key in tokenCategories[cat]) {
        const res = tokensParsed[cat][value];
        res != null && (valOrVar = res, hasSet = true);
      }
    }
    if (!hasSet) {
      const spaceVar = tokensParsed.space[value];
      spaceVar != null && (valOrVar = spaceVar, hasSet = true);
    }
  }
  if (hasSet) {
    const out = resolveVariableValue(key, valOrVar, resolveAs);
    return styleState.debug === "verbose" && (globalThis.tamaguiAvoidTracking = true, console.info("resolved", resolveAs, valOrVar, out), globalThis.tamaguiAvoidTracking = false), out;
  }
  styleState.debug === "verbose" && console.warn(`Warning: no token found for ${key}, omitting`);
};
function resolveVariableValue(key, valOrVar, resolveValues) {
  if (resolveValues === "none") return valOrVar;
  if (isVariable(valOrVar)) {
    if (resolveValues === "value") return valOrVar.val;
    const get = valOrVar == null ? void 0 : valOrVar.get;
    return typeof get == "function" ? get(resolveValues === "web" ? "web" : void 0) : valOrVar.variable;
  }
  return valOrVar;
}

// node_modules/@tamagui/web/dist/esm/helpers/sortString.mjs
var sortString = (a, b) => a < b ? -1 : a > b ? 1 : 0;

// node_modules/@tamagui/web/dist/esm/helpers/getSplitStyles.mjs
var conf3;
var PROP_SPLIT = "-";
function isValidStyleKey(key, validStyles2, accept) {
  return key in validStyles2 ? true : accept && key in accept;
}
var getSplitStyles = (props, staticConfig, theme, themeName, componentState, styleProps, parentSplitStyles, context, elementType, debug) => {
  var _a2, _b, _c, _d;
  conf3 = conf3 || getConfig(), isWeb && styleProps.isAnimated && conf3.animations.isReactNative && !styleProps.noNormalize && (styleProps.noNormalize = "values");
  const {
    shorthands
  } = conf3, {
    isHOC,
    isText,
    isInput,
    variants,
    isReactNative,
    inlineProps,
    inlineWhenUnflattened,
    parentStaticConfig,
    acceptsClassName
  } = staticConfig, viewProps = {}, mediaState2 = styleProps.mediaState || mediaState, usedKeys = {}, shouldDoClasses = acceptsClassName && isWeb && !styleProps.noClass, rulesToInsert = {}, classNames = {};
  let pseudos = null, space = props.space, hasMedia = false, dynamicThemeAccess, pseudoGroups, mediaGroups, className = props.className || "", mediaStylesSeen = 0;
  const validStyles2 = staticConfig.validStyles || (staticConfig.isText || staticConfig.isInput ? stylePropsText : validStyles);
  debug === "profile" && time`split-styles-setup`;
  const styleState = {
    classNames,
    conf: conf3,
    props,
    styleProps,
    componentState,
    staticConfig,
    style: null,
    theme,
    usedKeys,
    viewProps,
    context,
    debug
  };
  if (process.env.IS_STATIC === "is_static") {
    const {
      fallbackProps
    } = styleProps;
    fallbackProps && (styleState.props = new Proxy(props, {
      get(_, key, val) {
        return Reflect.has(props, key) ? Reflect.get(props, key) : Reflect.get(fallbackProps, key);
      }
    }));
  }
  debug === "profile" && time`style-state`, debug && debug !== "profile" && isClient && (groupCollapsed("getSplitStyles (collapsed)"), log({
    props,
    staticConfig,
    shouldDoClasses,
    styleProps,
    rulesToInsert,
    componentState,
    styleState,
    theme: {
      ...theme
    }
  }), groupEnd());
  const {
    asChild
  } = props, {
    accept
  } = staticConfig, {
    noSkip,
    disableExpandShorthands,
    noExpand
  } = styleProps, {
    webContainerType
  } = conf3.settings, parentVariants = parentStaticConfig == null ? void 0 : parentStaticConfig.variants;
  for (const keyOg in props) {
    let keyInit = keyOg, valInit = props[keyInit];
    if (keyInit === "children") {
      viewProps[keyInit] = valInit;
      continue;
    }
    if (debug === "profile" && time`before-prop-${keyInit}`, false) continue;
    if (accept) {
      const accepted = accept[keyInit];
      if ((accepted === "style" || accepted === "textStyle") && valInit && typeof valInit == "object") {
        viewProps[keyInit] = getSubStyle(styleState, keyInit, valInit, styleProps.noClass);
        continue;
      }
    }
    if (debug === "verbose" && groupEnd(), disableExpandShorthands || keyInit in shorthands && (keyInit = shorthands[keyInit]), keyInit === "className" || keyInit in usedKeys || asChild && webViewFlexCompatStyles[keyInit] === valInit) continue;
    if (keyInit in skipProps && !noSkip && !isHOC) {
      if (keyInit === "group") {
        const identifier = `t_group_${valInit}`, containerCSS = ["continer", void 0, identifier, void 0, [`.${identifier} { container-name: ${valInit}; container-type: ${webContainerType || "inline-size"}; }`]];
        addStyleToInsertRules(rulesToInsert, containerCSS);
      }
      continue;
    }
    const valInitType = typeof valInit;
    let isValidStyleKeyInit = isValidStyleKey(keyInit, validStyles2, accept);
    if (staticConfig.isReactNative && keyInit.startsWith("data-")) {
      keyInit = keyInit.replace("data-", ""), viewProps.dataSet || (viewProps.dataSet = {}), viewProps.dataSet[keyInit] = valInit;
      continue;
    }
    if (keyInit === "dataSet") {
      for (const keyInit2 in valInit) viewProps[`data-${hyphenate(keyInit2)}`] = valInit[keyInit2];
      continue;
    }
    if (!noExpand) {
      if (keyInit === "disabled" && valInit === true && (viewProps["aria-disabled"] = true, (elementType === "button" || elementType === "form" || elementType === "input" || elementType === "select" || elementType === "textarea") && (viewProps.disabled = true), !(variants == null ? void 0 : variants.disabled))) continue;
      if (keyInit === "testID") {
        viewProps[isReactNative ? keyInit : "data-testid"] = valInit;
        continue;
      }
      if (keyInit === "id" || keyInit === "nativeID") {
        viewProps.id = valInit;
        continue;
      }
      let didUseKeyInit = false;
      if (isReactNative) {
        if (keyInit in accessibilityDirectMap || keyInit.startsWith("accessibility")) {
          viewProps[keyInit] = valInit;
          continue;
        }
      } else {
        if (didUseKeyInit = true, keyInit in accessibilityDirectMap) {
          viewProps[accessibilityDirectMap[keyInit]] = valInit;
          continue;
        }
        switch (keyInit) {
          case "accessibilityRole": {
            valInit === "none" ? viewProps.role = "presentation" : viewProps.role = accessibilityRoleToWebRole[valInit] || valInit;
            continue;
          }
          case "accessibilityLabelledBy":
          case "accessibilityFlowTo":
          case "accessibilityControls":
          case "accessibilityDescribedBy": {
            viewProps[`aria-${keyInit.replace("accessibility", "").toLowerCase()}`] = processIDRefList(valInit);
            continue;
          }
          case "accessibilityKeyShortcuts": {
            Array.isArray(valInit) && (viewProps["aria-keyshortcuts"] = valInit.join(" "));
            continue;
          }
          case "accessibilityLiveRegion": {
            viewProps["aria-live"] = valInit === "none" ? "off" : valInit;
            continue;
          }
          case "accessibilityReadOnly": {
            viewProps["aria-readonly"] = valInit, (elementType === "input" || elementType === "select" || elementType === "textarea") && (viewProps.readOnly = true);
            continue;
          }
          case "accessibilityRequired": {
            viewProps["aria-required"] = valInit, (elementType === "input" || elementType === "select" || elementType === "textarea") && (viewProps.required = valInit);
            continue;
          }
          default:
            didUseKeyInit = false;
        }
      }
      if (didUseKeyInit) continue;
    }
    let isVariant = !isValidStyleKeyInit && variants && keyInit in variants;
    const isStyleLikeKey = isValidStyleKeyInit || isVariant;
    let isPseudo = keyInit in validPseudoKeys, isMedia = !isStyleLikeKey && !isPseudo && isMediaKey(keyInit), isMediaOrPseudo = !!(isMedia || isPseudo);
    if (isMediaOrPseudo && keyInit.startsWith("$group-")) {
      const parts = keyInit.split("-");
      if (
        // check if its actually a simple group selector to avoid breaking selectors
        parts.length === 2 || parts.length === 3 && pseudoPriorities[parts[parts.length - 1]]
      ) {
        const name = parts[1];
        (context == null ? void 0 : context.groups.subscribe) && !(context == null ? void 0 : context.groups.state[name]) && (keyInit = keyInit.replace("$group-", "$group-true-"));
      }
    }
    const isStyleProp = isValidStyleKeyInit || isMediaOrPseudo || isVariant && !noExpand;
    if (isStyleProp && (asChild === "except-style" || asChild === "except-style-web")) continue;
    const shouldPassProp = !isStyleProp && isHOC || // is in parent variants
    isHOC && parentVariants && keyInit in parentVariants || (inlineProps == null ? void 0 : inlineProps.has(keyInit)), parentVariant = parentVariants == null ? void 0 : parentVariants[keyInit], isHOCShouldPassThrough = !!(isHOC && (isValidStyleKeyInit || isMediaOrPseudo || parentVariant || keyInit in skipProps)), shouldPassThrough = shouldPassProp || isHOCShouldPassThrough;
    if (debug === "verbose" && (groupEnd(), groupEnd(), groupCollapsed(`  🔑 ${keyOg}${keyInit !== keyOg ? ` (shorthand for ${keyInit})` : ""} ${shouldPassThrough ? "(pass)" : ""}`), log({
      isVariant,
      valInit,
      shouldPassProp
    }), isClient && log({
      variants,
      variant: variants == null ? void 0 : variants[keyInit],
      isVariant,
      isHOCShouldPassThrough,
      parentStaticConfig
    })), shouldPassThrough && (passDownProp(viewProps, keyInit, valInit, isMediaOrPseudo), !isVariant) || !noSkip && keyInit in skipProps) continue;
    (isText || isInput) && valInit && (keyInit === "fontFamily" || keyInit === shorthands.fontFamily) && valInit in conf3.fontsParsed && (styleState.fontFamily = valInit);
    const disablePropMap = isMediaOrPseudo || !isStyleLikeKey;
    if (propMapper(keyInit, valInit, styleState, disablePropMap, (key, val) => {
      var _a3, _b2, _c2;
      const isStyledContextProp = styleProps.styledContextProps && key in styleProps.styledContextProps;
      if (!isHOC && disablePropMap && !isStyledContextProp && !isMediaOrPseudo) {
        viewProps[key] = val;
        return;
      }
      if (debug === "verbose" && (groupCollapsed("  💠 expanded", keyInit, "=>", key), log(val), groupEnd()), val == null || key in usedKeys) return;
      if (!isHOC && isValidStyleKey(key, validStyles2, accept)) {
        mergeStyle(styleState, key, val);
        return;
      }
      if (isPseudo = key in validPseudoKeys, isMedia = !isPseudo && isMediaKey(key), isMediaOrPseudo = !!(isMedia || isPseudo), isVariant = variants && key in variants, ((inlineProps == null ? void 0 : inlineProps.has(key)) || process.env.IS_STATIC === "is_static" && (inlineWhenUnflattened == null ? void 0 : inlineWhenUnflattened.has(key))) && (viewProps[key] = props[key] ?? val), styleProps.noExpand && isPseudo || isHOC && (isMediaOrPseudo || ((_a3 = parentStaticConfig == null ? void 0 : parentStaticConfig.variants) == null ? void 0 : _a3[keyInit]))) {
        passDownProp(viewProps, key, val, isMediaOrPseudo), debug === "verbose" && (groupCollapsed(` - passing down prop ${key}`), log({
          val,
          after: {
            ...viewProps[key]
          }
        }), groupEnd());
        return;
      }
      if (isPseudo) {
        if (!val) return;
        const pseudoStyleObject = getSubStyle(styleState, key, val, styleProps.noClass && process.env.IS_STATIC !== "is_static");
        if ((!shouldDoClasses || process.env.IS_STATIC === "is_static") && (pseudos || (pseudos = {}), pseudos[key] || (pseudos[key] = {}), process.env.IS_STATIC === "is_static")) {
          Object.assign(pseudos[key], pseudoStyleObject);
          return;
        }
        const descriptor = pseudoDescriptors[key], isEnter = key === "enterStyle", isExit = key === "exitStyle";
        if (!descriptor) return;
        if (shouldDoClasses && !isExit) {
          const pseudoStyles = getStyleAtomic(pseudoStyleObject, descriptor);
          debug === "verbose" && console.info("pseudo:", key, pseudoStyleObject, pseudoStyles);
          for (const psuedoStyle of pseudoStyles) {
            const fullKey = `${psuedoStyle[StyleObjectProperty]}${PROP_SPLIT}${descriptor.name}`;
            fullKey in usedKeys || (addStyleToInsertRules(rulesToInsert, psuedoStyle), classNames[fullKey] = psuedoStyle[StyleObjectIdentifier]);
          }
        }
        if (!shouldDoClasses || isExit || isEnter) {
          const descriptorKey = descriptor.stateKey || descriptor.name;
          let isDisabled2 = componentState[descriptorKey] === false;
          isExit && (isDisabled2 = !styleProps.isExiting), isEnter && componentState.unmounted === false && (isDisabled2 = true), debug === "verbose" && (groupCollapsed("pseudo", key, {
            isDisabled: isDisabled2
          }), log({
            pseudoStyleObject,
            isDisabled: isDisabled2,
            descriptor,
            componentState
          }), groupEnd());
          const importance = descriptor.priority;
          for (const pkey in pseudoStyleObject) {
            const val2 = pseudoStyleObject[pkey];
            if (isDisabled2) applyDefaultStyle(pkey, styleState);
            else {
              const curImportance = usedKeys[pkey] || 0, shouldMerge = importance >= curImportance;
              shouldMerge && (process.env.IS_STATIC === "is_static" && (pseudos || (pseudos = {}), pseudos[key] || (pseudos[key] = {}), pseudos[key][pkey] = val2), mergeStyle(styleState, pkey, val2)), debug === "verbose" && log("    subKey", pkey, shouldMerge, {
                importance,
                curImportance,
                pkey,
                val: val2
              });
            }
          }
          if (!isDisabled2) for (const key2 in val) {
            const k = shorthands[key2] || key2;
            usedKeys[k] = Math.max(importance, usedKeys[k] || 0);
          }
        }
        return;
      }
      if (isMedia) {
        if (!val) return;
        const hasSpace = val.space, mediaKeyShort = key.slice(isMedia == "theme" ? 7 : 1);
        if (hasMedia || (hasMedia = true), (hasSpace || !shouldDoClasses || styleProps.willBeAnimated) && ((!hasMedia || typeof hasMedia == "boolean") && (hasMedia = /* @__PURE__ */ new Set()), hasMedia.add(mediaKeyShort)), isMedia === "platform" && !isActivePlatform(key)) return;
        if (debug === "verbose" && log(`  📺 ${key}`, {
          key,
          val,
          props,
          shouldDoClasses,
          acceptsClassName,
          componentState,
          mediaState: mediaState2
        }), shouldDoClasses) {
          const mediaStyle = getSubStyle(styleState, key, val, false);
          if (hasSpace && (delete mediaStyle.space, mediaState2[mediaKeyShort])) {
            const importance = getMediaImportanceIfMoreImportant(mediaKeyShort, "space", usedKeys, true);
            importance && (space = val.space, usedKeys.space = importance, debug === "verbose" && log(`Found more important space for current media ${mediaKeyShort}: ${val} (importance: ${importance})`));
          }
          const mediaStyles = getCSSStylesAtomic(mediaStyle), priority = mediaStylesSeen;
          mediaStylesSeen += 1;
          for (const style of mediaStyles) {
            const property = style[StyleObjectProperty], isSubStyle = property[0] === "$";
            if (isSubStyle && !isActivePlatform(property)) continue;
            const out = createMediaStyle(style, mediaKeyShort, mediaQueryConfig, isMedia, false, priority);
            debug === "verbose" && log("📺 media style:", out);
            const subKey = isSubStyle ? style[2] : "", fullKey = `${style[StyleObjectProperty]}${subKey}${PROP_SPLIT}${mediaKeyShort}${style[StyleObjectPseudo] || ""}`;
            fullKey in usedKeys || (addStyleToInsertRules(rulesToInsert, out), classNames[fullKey] = out[StyleObjectIdentifier]);
          }
        } else {
          let mergeMediaStyle = function(key2, val2) {
            styleState.style || (styleState.style = {}), mergeMediaByImportance(styleState, mediaKeyShort, key2, val2, usedKeys, mediaState2[mediaKeyShort], importanceBump, debug) && key2 === "fontFamily" && (styleState.fontFamily = mediaStyle.fontFamily);
          };
          const isThemeMedia = isMedia === "theme", isGroupMedia = isMedia === "group";
          if (!isThemeMedia && !(isMedia === "platform") && !isGroupMedia) {
            if (!mediaState2[mediaKeyShort]) {
              debug === "verbose" && log(`  📺 ❌ DISABLED ${mediaKeyShort}`);
              return;
            }
            debug === "verbose" && log(`  📺 ✅ ENABLED ${mediaKeyShort}`);
          }
          const mediaStyle = getSubStyle(styleState, key, val, true);
          let importanceBump = 0;
          if (isThemeMedia) {
            if (dynamicThemeAccess = true, !(themeName === mediaKeyShort || themeName.startsWith(mediaKeyShort))) return;
          } else if (isGroupMedia) {
            const groupInfo = getGroupPropParts(mediaKeyShort), groupName = groupInfo.name, groupContext = context == null ? void 0 : context.groups.state[groupName];
            if (!groupContext) {
              debug && log(`No parent with group prop, skipping styles: ${groupName}`);
              return;
            }
            const groupPseudoKey = groupInfo.pseudo, groupMediaKey = groupInfo.media, componentGroupState = (_b2 = componentState.group) == null ? void 0 : _b2[groupName];
            if (groupMediaKey) {
              mediaGroups || (mediaGroups = /* @__PURE__ */ new Set()), mediaGroups.add(groupMediaKey);
              const mediaState22 = componentGroupState == null ? void 0 : componentGroupState.media;
              let isActive = mediaState22 == null ? void 0 : mediaState22[groupMediaKey];
              if (!mediaState22 && groupContext.layout && (isActive = mediaKeyMatch(groupMediaKey, groupContext.layout)), debug === "verbose" && log(` 🏘️ GROUP media ${groupMediaKey} active? ${isActive}`), !isActive) {
                for (const pkey in mediaStyle) applyDefaultStyle(pkey, styleState);
                return;
              }
              importanceBump = 2;
            }
            if (groupPseudoKey) {
              pseudoGroups || (pseudoGroups = /* @__PURE__ */ new Set()), pseudoGroups.add(groupName);
              const isActive = (_c2 = (componentGroupState || // fallback to context initially
              context.groups.state[groupName]).pseudo) == null ? void 0 : _c2[groupPseudoKey], priority = pseudoPriorities[groupPseudoKey];
              if (debug === "verbose" && log(` 🏘️ GROUP pseudo ${groupMediaKey} active? ${isActive}, priority ${priority}`), !isActive) {
                for (const pkey in mediaStyle) applyDefaultStyle(pkey, styleState);
                return;
              }
              importanceBump = priority;
            }
          }
          for (const subKey in mediaStyle) {
            if (subKey === "space") {
              space = valInit.space;
              continue;
            }
            if (subKey[0] === "$") {
              if (!isActivePlatform(subKey) || !isActiveTheme(subKey, themeName)) continue;
              for (const subSubKey in mediaStyle[subKey]) mergeMediaStyle(subSubKey, mediaStyle[subKey][subSubKey]);
            } else mergeMediaStyle(subKey, mediaStyle[subKey]);
          }
        }
        return;
      }
      if (!isVariant) {
        if (isStyledContextProp) return;
        viewProps[key] = val;
      }
    }), debug === "verbose") {
      try {
        log(" ✔️ expand complete", keyInit), log("style", {
          ...styleState.style
        }), log("viewProps", {
          ...viewProps
        });
      } catch {
      }
      groupEnd();
    }
  }
  if (debug === "profile" && time`split-styles-propsend`, !(styleProps.noNormalize === false) && (styleState.style && (fixStyles(styleState.style), !styleProps.noExpand && !styleProps.noMergeStyle && isWeb && !isReactNative && styleToCSS(styleState.style)), styleState.flatTransforms && (styleState.style || (styleState.style = {}), mergeFlatTransforms(styleState.style, styleState.flatTransforms)), parentSplitStyles)) {
    if (shouldDoClasses) for (const key in parentSplitStyles.classNames) {
      const val = parentSplitStyles.classNames[key];
      styleState.style && key in styleState.style || key in classNames || (classNames[key] = val);
    }
    if (!shouldDoClasses) for (const key in parentSplitStyles.style) key in classNames || styleState.style && key in styleState.style || (styleState.style || (styleState.style = {}), styleState.style[key] = parentSplitStyles.style[key]);
  }
  if (!styleProps.noNormalize && !staticConfig.isReactNative && !staticConfig.isHOC && (!styleProps.isAnimated || conf3.animations.supportsCSSVars) && Array.isArray((_a2 = styleState.style) == null ? void 0 : _a2.transform) && (styleState.style.transform = transformsToString(styleState.style.transform)), !styleProps.noMergeStyle && styleState.style && shouldDoClasses) {
    let retainedStyles, shouldRetain = false;
    if (!styleState.style.$$css) {
      const atomic = getCSSStylesAtomic(styleState.style);
      for (const atomicStyle of atomic) {
        const [key, value, identifier] = atomicStyle, isAnimatedAndAnimateOnly = styleProps.isAnimated && styleProps.noClass && ((_b = props.animateOnly) == null ? void 0 : _b.includes(key)), nonAnimatedAnimateOnly = !isAnimatedAndAnimateOnly && !styleProps.isAnimated && ((_c = props.animateOnly) == null ? void 0 : _c.includes(key));
        isAnimatedAndAnimateOnly ? (retainedStyles || (retainedStyles = {}), retainedStyles[key] = styleState.style[key]) : nonAnimatedAnimateOnly ? (retainedStyles || (retainedStyles = {}), retainedStyles[key] = value, shouldRetain = true) : (addStyleToInsertRules(rulesToInsert, atomicStyle), classNames[key] = identifier);
      }
      props.debug === "verbose" && (groupEnd(), groupCollapsed("🔹 getSplitStyles final style object"), console.info(styleState.style), console.info("retainedStyles", retainedStyles), groupEnd()), (shouldRetain || process.env.IS_STATIC !== "is_static") && (styleState.style = retainedStyles || {});
    }
  }
  if (isReactNative) viewProps.tabIndex === 0 && (viewProps.accessible ?? (viewProps.accessible = true));
  else if (viewProps.tabIndex == null) {
    const isFocusable = viewProps.focusable ?? viewProps.accessible;
    viewProps.focusable && delete viewProps.focusable;
    const role = viewProps.role;
    isFocusable === false && (viewProps.tabIndex = "-1"), // These native elements are focusable by default
    elementType === "a" || elementType === "button" || elementType === "input" || elementType === "select" || elementType === "textarea" ? (isFocusable === false || props.accessibilityDisabled === true) && (viewProps.tabIndex = "-1") : (
      // These roles are made focusable by default
      (role === "button" || role === "checkbox" || role === "link" || role === "radio" || // @ts-expect-error (consistent with RNW)
      role === "textbox" || role === "switch") && isFocusable !== false && (viewProps.tabIndex = "0")
    ), isFocusable && (viewProps.tabIndex = "0", delete viewProps.focusable);
  }
  const styleProp = props.style;
  if (!styleProps.noMergeStyle && styleProp) if (isHOC) viewProps.style = normalizeStyle2(styleProp);
  else {
    const isArray = Array.isArray(styleProp), len = isArray ? styleProp.length : 1;
    for (let i = 0; i < len; i++) {
      const style = isArray ? styleProp[i] : styleProp;
      style && (style.$$css ? Object.assign(styleState.classNames, style) : (styleState.style || (styleState.style = {}), Object.assign(styleState.style, normalizeStyle2(style))));
    }
  }
  debug === "profile" && time`split-styles-pre-result`;
  const result = {
    space,
    hasMedia,
    fontFamily: styleState.fontFamily,
    viewProps,
    style: styleState.style,
    pseudos,
    classNames,
    rulesToInsert,
    dynamicThemeAccess,
    pseudoGroups,
    mediaGroups
  }, asChildExceptStyleLike = asChild === "except-style" || asChild === "except-style-web";
  if (!styleProps.noMergeStyle && !asChildExceptStyleLike) {
    const style = styleState.style;
    {
      let fontFamily = isText || isInput ? styleState.fontFamily || ((_d = staticConfig.defaultProps) == null ? void 0 : _d.fontFamily) : null;
      fontFamily && fontFamily[0] === "$" && (fontFamily = fontFamily.slice(1));
      const fontFamilyClassName = fontFamily ? `font_${fontFamily}` : "", groupClassName = props.group ? `t_group_${props.group}` : "", componentNameFinal = props.componentName || staticConfig.componentName, componentClassName = props.asChild || !componentNameFinal ? "" : `is_${componentNameFinal}`;
      let classList = [];
      componentClassName && classList.push(componentClassName), fontFamilyClassName && classList.push(fontFamilyClassName), classNames && classList.push(Object.values(classNames).join(" ")), groupClassName && classList.push(groupClassName), props.className && classList.push(props.className);
      const finalClassName = classList.join(" ");
      if (styleProps.isAnimated && !conf3.animations.supportsCSSVars && isReactNative) style && (viewProps.style = style);
      else if (isReactNative) {
        const cnStyles = {
          $$css: true
        };
        for (const name of finalClassName.split(" ")) cnStyles[name] = name;
        viewProps.style = [...Array.isArray(style) ? style : [style], cnStyles];
      } else finalClassName && (viewProps.className = finalClassName), style && (viewProps.style = style);
    }
  }
  if (debug === "verbose" && isDevTools) {
    groupCollapsed("🔹 getSplitStyles ===>");
    try {
      const logs = {
        ...result,
        className,
        componentState,
        viewProps,
        rulesToInsert,
        parentSplitStyles
      };
      for (const key in logs) log(key, logs[key]);
    } catch {
    }
    groupEnd();
  }
  return debug === "profile" && time`split-styles-done`, result;
};
function mergeFlatTransforms(target, flatTransforms) {
  Object.entries(flatTransforms).sort(([a], [b]) => sortString(a, b)).forEach(([key, val]) => {
    mergeTransform(target, key, val, true);
  });
}
function mergeStyle(styleState, key, val, disableNormalize = false) {
  const {
    viewProps,
    styleProps,
    staticConfig
  } = styleState;
  if (key in stylePropsTransform) styleState.flatTransforms || (styleState.flatTransforms = {}), styleState.flatTransforms[key] = val;
  else {
    const out = isWeb && !disableNormalize && !styleProps.noNormalize ? normalizeValueWithProperty(val, key) : val;
    staticConfig.accept && key in staticConfig.accept ? viewProps[key] = out : (styleState.style || (styleState.style = {}), styleState.style[key] = // if you dont do this you'll be passing props.transform arrays directly here and then mutating them
    // if theres any flatTransforms later, causing issues (mutating props is bad, in strict mode styles get borked)
    key === "transform" && Array.isArray(out) ? [...out] : out);
  }
}
var getSubStyle = (styleState, subKey, styleIn, avoidMergeTransform) => {
  var _a2;
  const {
    staticConfig,
    conf: conf22,
    styleProps
  } = styleState, styleOut = {};
  for (let key in styleIn) {
    const val = styleIn[key];
    key = conf22.shorthands[key] || key, !(!staticConfig.isHOC && key in skipProps && !styleProps.noSkip) && propMapper(key, val, styleState, false, (skey, sval) => {
      skey in validPseudoKeys && (sval = getSubStyle(styleState, skey, sval, avoidMergeTransform)), !avoidMergeTransform && skey in stylePropsTransform ? mergeTransform(styleOut, skey, sval) : styleOut[skey] = styleProps.noNormalize ? sval : normalizeValueWithProperty(sval, key);
    });
  }
  if (!avoidMergeTransform) {
    if (Array.isArray(styleOut.transform)) {
      const parentTransform = (_a2 = styleState.style) == null ? void 0 : _a2.transform;
      parentTransform && (styleOut.transform = [...parentTransform, ...styleOut.transform]);
    }
    styleState.flatTransforms && mergeFlatTransforms(styleOut, styleState.flatTransforms);
  }
  return styleProps.noNormalize || fixStyles(styleOut), styleOut;
};
var useInsertEffectCompat = isWeb ? import_react10.default.useInsertionEffect || useIsomorphicLayoutEffect : () => {
};
var useSplitStyles = (a, b, c, d, e, f, g, h, i, j) => {
  conf3 = conf3 || getConfig();
  const res = getSplitStyles(a, b, c, d, e, f, g, h, i, j);
  return process.env.TAMAGUI_REACT_19 || useInsertEffectCompat(() => {
    insertStyleRules(res.rulesToInsert);
  }, [res.rulesToInsert]), res;
};
function addStyleToInsertRules(rulesToInsert, styleObject) {
  {
    const identifier = styleObject[StyleObjectIdentifier];
    process.env.TAMAGUI_REACT_19 || shouldInsertStyleRules(identifier) && updateRules(identifier, styleObject[StyleObjectRules]), rulesToInsert[identifier] = styleObject;
  }
}
function processIDRefList(idRefList) {
  return Array.isArray(idRefList) ? idRefList.join(" ") : idRefList;
}
var defaultColor = process.env.TAMAGUI_DEFAULT_COLOR || "rgba(0,0,0,0)";
var animatableDefaults = {
  ...Object.fromEntries(Object.entries(tokenCategories.color).map(([k, v]) => [k, defaultColor])),
  opacity: 1,
  scale: 1,
  rotate: "0deg",
  rotateY: "0deg",
  rotateX: "0deg",
  x: 0,
  y: 0,
  borderRadius: 0
};
var lowercaseHyphenate = (match) => `-${match.toLowerCase()}`;
var hyphenate = (str) => str.replace(/[A-Z]/g, lowercaseHyphenate);
var mergeTransform = (obj, key, val, backwards = false) => {
  typeof obj.transform != "string" && (obj.transform || (obj.transform = []), obj.transform[backwards ? "unshift" : "push"]({
    [mapTransformKeys[key] || key]: val
  }));
};
var mapTransformKeys = {
  x: "translateX",
  y: "translateY"
};
var accessibilityRoleToWebRole = {
  adjustable: "slider",
  header: "heading",
  image: "img",
  link: "link",
  none: "presentation",
  summary: "region"
};
function passDownProp(viewProps, key, val, shouldMergeObject = false) {
  if (shouldMergeObject) {
    const next = {
      ...viewProps[key],
      ...val
    };
    delete viewProps[key], viewProps[key] = next;
  } else viewProps[key] = val;
}
function mergeMediaByImportance(styleState, mediaKey, key, value, importancesUsed, isSizeMedia, importanceBump, debugProp) {
  let importance = getMediaImportanceIfMoreImportant(mediaKey, key, importancesUsed, isSizeMedia);
  if (importanceBump && (importance = (importance || 0) + importanceBump), debugProp === "verbose" && log(`mergeMediaByImportance ${key} importance existing ${importancesUsed[key]} next ${importance}`), importance === null) return false;
  if (importancesUsed[key] = importance, key in pseudoDescriptors) {
    const descriptor = pseudoDescriptors[key], descriptorKey = descriptor.stateKey || descriptor.name;
    if (styleState.componentState[descriptorKey] === false) return false;
    for (const subKey in value) mergeStyle(styleState, subKey, value[subKey]);
  } else mergeStyle(styleState, key, value);
  return true;
}
function normalizeStyle2(style) {
  const out = {};
  for (const key in style) {
    const val = style[key];
    key in stylePropsTransform ? mergeTransform(out, key, val) : out[key] = normalizeValueWithProperty(val, key);
  }
  return isWeb && Array.isArray(out.transform) && (out.transform = transformsToString(out.transform)), fixStyles(out), out;
}
function applyDefaultStyle(pkey, styleState) {
  const defaultValues = animatableDefaults[pkey];
  defaultValues != null && !(pkey in styleState.usedKeys) && (!styleState.style || !(pkey in styleState.style)) && mergeStyle(styleState, pkey, defaultValues);
}

// node_modules/@tamagui/web/dist/esm/helpers/mergeProps.mjs
var mergeProps = (a, b, inverseShorthands2) => {
  const out = {};
  for (const key in a) mergeProp(out, a, b, key, inverseShorthands2);
  if (b) for (const key in b) mergeProp(out, b, void 0, key, inverseShorthands2);
  return out;
};
function mergeProp(out, a, b, key, inverseShorthands2) {
  const longhand = (inverseShorthands2 == null ? void 0 : inverseShorthands2[key]) || null, val = a[key];
  if (key in pseudoDescriptors || mediaKeys.has(key)) {
    out[key] = {
      ...out[key],
      ...val
    };
    return;
  }
  b && (key in b || longhand && longhand in b) || (out[longhand || key] = val);
}

// node_modules/@tamagui/web/dist/esm/setupHooks.mjs
var hooks = {};
function setupHooks(next) {
  Object.assign(hooks, next);
}

// node_modules/@tamagui/web/dist/esm/helpers/setElementProps.mjs
var setElementProps = (node2) => {
  var _a2, _b;
  (_b = (_a2 = hooks).setElementProps) == null ? void 0 : _b.call(_a2, node2);
};

// node_modules/@tamagui/web/dist/esm/helpers/createShallowSetState.mjs
var import_react11 = __toESM(require_react(), 1);
var callImmediate = (cb) => cb();
function createShallowSetState(setter, onlyAllow, transition, debugIn) {
  return (0, import_react11.useCallback)((next) => {
    (transition ? import_react11.startTransition : callImmediate)(() => {
      setter((prev) => mergeIfNotShallowEqual(prev, next, onlyAllow, debugIn));
    });
  }, [setter, onlyAllow ? onlyAllow.join("") : "", transition, debugIn]);
}
function mergeIfNotShallowEqual(prev, next, onlyAllow, debug) {
  if (onlyAllow) {
    let allowed = {};
    for (const key in next) onlyAllow.includes(key) && (allowed[key] = next[key]);
    next = allowed;
  }
  if (!prev || !next || isEqualShallow(prev, next)) return prev || next;
  if (debug && (console.info("setStateShallow CHANGE", {
    prev,
    next
  }), debug === "break")) debugger;
  return {
    ...prev,
    ...next
  };
}
function isEqualShallow(prev, next) {
  for (const key in next) if (prev[key] !== next[key]) return false;
  return true;
}

// node_modules/@tamagui/web/dist/esm/helpers/subscribeToContextGroup.mjs
var subscribeToContextGroup = ({
  setStateShallow,
  pseudoGroups,
  mediaGroups,
  componentContext,
  state
}) => {
  var _a2, _b;
  if (pseudoGroups || mediaGroups) return !componentContext.groups && console.debug("No context group found"), (_b = (_a2 = componentContext.groups) == null ? void 0 : _a2.subscribe) == null ? void 0 : _b.call(_a2, (name, {
    layout,
    pseudo
  }) => {
    var _a3;
    const current = ((_a3 = state.group) == null ? void 0 : _a3[name]) || {
      pseudo: {},
      media: {}
    };
    if (pseudo && (pseudoGroups == null ? void 0 : pseudoGroups.has(String(name)))) Object.assign(current.pseudo, pseudo), persist();
    else if (layout && mediaGroups) {
      const mediaState2 = getMediaState(mediaGroups, layout), next = mergeIfNotShallowEqual(current.media, mediaState2);
      next !== current.media && (Object.assign(current.media, next), persist());
    }
    function persist() {
      const group = {
        ...state.group,
        [name]: current
      };
      setStateShallow({
        group
      });
    }
  });
};

// node_modules/@tamagui/web/dist/esm/helpers/wrapStyleTags.mjs
var import_jsx_runtime5 = __toESM(require_jsx_runtime(), 1);
function wrapStyleTags(styles, content) {
  return process.env.TAMAGUI_REACT_19 && styles.length ? (0, import_jsx_runtime5.jsxs)(import_jsx_runtime5.Fragment, {
    children: [content, styles.map((styleObject) => {
      const identifier = styleObject[StyleObjectIdentifier];
      return (0, import_jsx_runtime5.jsx)("style", {
        href: `t_${identifier}`,
        precedence: "default",
        children: styleObject[StyleObjectRules].join(`
`)
      }, identifier);
    })]
  }) : content;
}

// node_modules/@tamagui/web/dist/esm/hooks/useComponentState.mjs
var import_react12 = __toESM(require_react(), 1);
var useComponentState = (props, {
  animationDriver
}, staticConfig, config) => {
  var _a2;
  const isHydrated = useDidFinishSSR(), useAnimations = animationDriver == null ? void 0 : animationDriver.useAnimations, stateRef = (0, import_react12.useRef)(void 0);
  stateRef.current || (stateRef.current = {});
  const hasAnimationProp = !!("animation" in props || props.style && hasAnimatedStyleValue(props.style)), supportsCSSVars = animationDriver == null ? void 0 : animationDriver.supportsCSSVars, curStateRef = stateRef.current, willBeAnimatedClient = !!(!!(hasAnimationProp && !staticConfig.isHOC && useAnimations) || curStateRef.hasAnimated), willBeAnimated = !isServer && willBeAnimatedClient;
  willBeAnimated && !curStateRef.hasAnimated && (curStateRef.hasAnimated = true);
  const {
    disableClassName
  } = props, presence = willBeAnimated && props.animatePresence !== false && ((_a2 = animationDriver == null ? void 0 : animationDriver.usePresence) == null ? void 0 : _a2.call(animationDriver)) || null, presenceState = presence == null ? void 0 : presence[2], isExiting = (presenceState == null ? void 0 : presenceState.isPresent) === false, isEntering = (presenceState == null ? void 0 : presenceState.isPresent) === true && presenceState.initial !== false, hasEnterStyle = !!props.enterStyle, hasAnimationThatNeedsHydrate = hasAnimationProp && !isHydrated && ((animationDriver == null ? void 0 : animationDriver.isReactNative) || !supportsCSSVars), hasEnterState = hasEnterStyle || isEntering, initialState = hasEnterState || hasAnimationThatNeedsHydrate || // disableClassName doesnt work server side, only client, so needs hydrate
  // this is just for a better ux, supports css variables for light/dark, media queries, etc
  disableClassName ? (
    // on the very first render we switch all spring animation drivers to css rendering
    // this is because we need to use css variables, which they don't support to do proper SSR
    // without flickers of the wrong colors.
    // but once we do that initial hydration and we are in client side rendering mode,
    // we can avoid the extra re-render on mount
    hasEnterState ? defaultComponentStateShouldEnter : defaultComponentState
  ) : defaultComponentStateMounted, disabled = isDisabled(props);
  disabled != null && (initialState.disabled = disabled);
  const states2 = (0, import_react12.useState)(initialState), state = props.forceStyle ? {
    ...states2[0],
    [props.forceStyle]: true
  } : states2[0], setState = states2[1];
  let isAnimated = willBeAnimated;
  isWeb && hasAnimationThatNeedsHydrate && !staticConfig.isHOC && !isHydrated && (isAnimated = false, curStateRef.willHydrate = true), disabled !== state.disabled && (state.disabled = disabled, disabled && Object.assign(state, defaultComponentStateMounted), setState({
    ...state
  }));
  const groupName = props.group;
  let setStateShallow = createShallowSetState(setState, disabled ? ["disabled"] : void 0, false, props.debug);
  if (presenceState && isAnimated && isHydrated && staticConfig.variants) {
    props.debug === "verbose" && console.warn(`has presenceState ${JSON.stringify(presenceState)}`);
    const {
      enterVariant,
      exitVariant,
      enterExitVariant,
      custom
    } = presenceState;
    isObj(custom) && Object.assign(props, custom);
    const exv = exitVariant ?? enterExitVariant, env = enterVariant ?? enterExitVariant;
    state.unmounted && env && staticConfig.variants[env] ? (props.debug === "verbose" && console.warn(`Animating presence ENTER "${env}"`), props[env] = true) : isExiting && exv && (props.debug === "verbose" && console.warn(`Animating presence EXIT "${exv}"`), props[exv] = exitVariant !== enterExitVariant);
  }
  let noClass = !isWeb || !!props.forceStyle;
  if (isWeb && (!isServer || isHydrated)) {
    const isAnimatedAndHydrated = isAnimated && !supportsCSSVars, isClassNameDisabled = !staticConfig.acceptsClassName && (config.disableSSR || !state.unmounted), isDisabledManually = disableClassName && !state.unmounted;
    (isAnimatedAndHydrated || isDisabledManually || isClassNameDisabled) && (noClass = true, props.debug && log("avoiding className", {
      isAnimatedAndHydrated,
      isDisabledManually,
      isClassNameDisabled
    }));
  }
  if (groupName && !curStateRef.group) {
    const listeners2 = /* @__PURE__ */ new Set();
    curStateRef.group = {
      listeners: listeners2,
      emit(name, state2) {
        listeners2.forEach((l) => l(name, state2));
      },
      subscribe(cb) {
        return listeners2.add(cb), () => {
          listeners2.delete(cb);
        };
      }
    };
  }
  return {
    curStateRef,
    disabled,
    groupName,
    hasAnimationProp,
    hasEnterStyle,
    isAnimated,
    isExiting,
    isHydrated,
    presence,
    presenceState,
    setState,
    setStateShallow,
    noClass,
    state,
    stateRef,
    supportsCSSVars,
    willBeAnimated,
    willBeAnimatedClient
  };
};
function hasAnimatedStyleValue(style) {
  return Object.keys(style).some((k) => {
    const val = style[k];
    return val && typeof val == "object" && "_animation" in val;
  });
}
var isDisabled = (props) => {
  var _a2;
  return props.disabled || ((_a2 = props.accessibilityState) == null ? void 0 : _a2.disabled) || props["aria-disabled"] || props.accessibilityDisabled || false;
};

// node_modules/@tamagui/web/dist/esm/views/Slot.mjs
var import_react13 = __toESM(require_react(), 1);
var import_jsx_runtime6 = __toESM(require_jsx_runtime(), 1);
var is19 = import_react13.version.startsWith("19.");
var Slot = (0, import_react13.memo)((0, import_react13.forwardRef)(function(props, forwardedRef) {
  const {
    children,
    ...slotProps
  } = props;
  if ((0, import_react13.isValidElement)(children)) {
    const mergedProps = mergeSlotProps(children, slotProps);
    return (0, import_react13.cloneElement)(children, children.type.avoidForwardRef ? mergedProps : {
      ...mergedProps,
      ref: composeRefs(forwardedRef, is19 ? children.props.ref : children.ref)
    });
  }
  return import_react13.Children.count(children) > 1 ? import_react13.Children.only(null) : null;
}));
var Slottable = ({
  children
}) => (0, import_jsx_runtime6.jsx)(import_jsx_runtime6.Fragment, {
  children
});
Slottable.displayName = "Slottable";
var pressMap = isWeb ? {
  onPress: "onClick",
  onPressOut: "onMouseUp",
  onPressIn: "onMouseDown"
} : {};
function mergeSlotProps(child, slotProps) {
  const childProps = child.props, overrideProps = {
    ...childProps
  }, isHTMLChild = typeof child.type == "string";
  if (isHTMLChild) for (const key in pressMap) key in slotProps && (slotProps[pressMap[key]] = slotProps[key], delete slotProps[key]);
  for (let propName in childProps) {
    const slotPropValue = slotProps[propName], childPropValue = childProps[propName];
    isHTMLChild && propName in pressMap && (propName = pressMap[propName], delete overrideProps[propName]), handleRegex.test(propName) ? overrideProps[propName] = composeEventHandlers(childPropValue, slotPropValue) : propName === "style" ? overrideProps[propName] = {
      ...slotPropValue,
      ...childPropValue
    } : propName === "className" && (overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(" "));
  }
  return {
    ...slotProps,
    ...overrideProps
  };
}
var handleRegex = /^on[A-Z]/;

// node_modules/@tamagui/web/dist/esm/createComponent.mjs
var import_jsx_runtime7 = __toESM(require_jsx_runtime(), 1);
var time2;
var debugKeyListeners;
var startVisualizer;
var componentSetStates = /* @__PURE__ */ new Set();
if (typeof document < "u") {
  const cancelTouches = () => {
    componentSetStates.forEach((setState) => setState((prev) => prev.press || prev.pressIn ? {
      ...prev,
      press: false,
      pressIn: false
    } : prev)), componentSetStates.clear();
  };
  addEventListener("mouseup", cancelTouches), addEventListener("touchend", cancelTouches), addEventListener("touchcancel", cancelTouches), startVisualizer = () => {
    var _a2;
    const devVisualizerConfig = (_a2 = devConfig) == null ? void 0 : _a2.visualizer;
    if (devVisualizerConfig) {
      debugKeyListeners = /* @__PURE__ */ new Set();
      let tm, isShowing = false;
      const options = {
        key: "Alt",
        delay: 800,
        ...typeof devVisualizerConfig == "object" ? devVisualizerConfig : {}
      };
      document.addEventListener("blur", () => {
        clearTimeout(tm);
      }), document.addEventListener("keydown", ({
        key,
        defaultPrevented
      }) => {
        defaultPrevented || (clearTimeout(tm), key === options.key && (tm = setTimeout(() => {
          isShowing = true, debugKeyListeners == null ? void 0 : debugKeyListeners.forEach((l) => l(true));
        }, options.delay)));
      }), document.addEventListener("keyup", ({
        key,
        defaultPrevented
      }) => {
        defaultPrevented || key === options.key && (clearTimeout(tm), isShowing && (debugKeyListeners == null ? void 0 : debugKeyListeners.forEach((l) => l(false))));
      });
    }
  };
}
var BaseText;
var BaseView;
var lastInteractionWasKeyboard = {
  value: false
};
isWeb && globalThis.document && (document.addEventListener("keydown", () => {
  lastInteractionWasKeyboard.value = true;
}), document.addEventListener("mousedown", () => {
  lastInteractionWasKeyboard.value = false;
}), document.addEventListener("mousemove", () => {
  lastInteractionWasKeyboard.value = false;
}));
function createComponent(staticConfig) {
  var _a2;
  const {
    componentName
  } = staticConfig;
  let config = null, defaultProps = staticConfig.defaultProps;
  onConfiguredOnce((conf4) => {
    var _a3;
    if (config = conf4, componentName) {
      const defaultForComponent = (_a3 = conf4.defaultProps) == null ? void 0 : _a3[componentName];
      defaultForComponent && (defaultProps = {
        ...defaultForComponent,
        ...defaultProps
      });
    }
  });
  const {
    Component,
    isText,
    isZStack,
    isHOC
  } = staticConfig;
  ((_a2 = staticConfig.defaultProps) == null ? void 0 : _a2.debug) && process.env.IS_STATIC !== "is_static" && log(`🐛 [${componentName || "Component"}]`, {
    staticConfig,
    defaultProps,
    defaultPropsKeyOrder: defaultProps ? Object.keys(defaultProps) : []
  });
  const component = import_react14.default.forwardRef((propsIn, forwardedRef) => {
    var _b, _c, _d, _e, _f, _g;
    const internalID = true ? import_react14.default.useId() : "";
    startVisualizer && (startVisualizer(), startVisualizer = void 0), false;
    const componentContext = import_react14.default.useContext(ComponentContext);
    let styledContextProps, overriddenContextProps, contextValue;
    const {
      context,
      isReactNative
    } = staticConfig;
    if (context && (contextValue = import_react14.default.useContext(context), contextValue)) {
      (defaultProps == null ? void 0 : defaultProps.debug) === "verbose" && log(" 👇 contextValue", contextValue);
      for (const key in context.props) {
        const propVal = getShorthandValue(propsIn, key);
        if (propVal === void 0) {
          const val = contextValue == null ? void 0 : contextValue[key];
          val !== void 0 && (styledContextProps || (styledContextProps = {}), styledContextProps[key] = val);
        }
        const finalVal = propVal ?? (defaultProps == null ? void 0 : defaultProps[key]);
        finalVal !== void 0 && (overriddenContextProps || (overriddenContextProps = {}), overriddenContextProps[key] = finalVal);
      }
    }
    const debugProp = propsIn.debug;
    !process.env.TAMAGUI_IS_CORE_NODE && true && debugProp === "profile" && !time2 && (time2 = require_cjs().timer().start(), globalThis.time = time2), time2 && time2`non-tamagui time (ignore)`;
    const curDefaultProps = styledContextProps ? {
      ...defaultProps,
      ...styledContextProps
    } : defaultProps;
    let props = propsIn;
    curDefaultProps && (props = mergeProps(curDefaultProps, propsIn));
    const componentName2 = props.componentName || staticConfig.componentName;
    isClient && import_react14.default.useEffect(() => {
      let overlay = null;
      const debugVisualizerHandler = (show = false) => {
        const node2 = curStateRef.host;
        if (node2) if (show) {
          overlay = document.createElement("span"), overlay.style.inset = "0px", overlay.style.zIndex = "1000000", overlay.style.position = "absolute", overlay.style.borderColor = "red", overlay.style.borderWidth = "1px", overlay.style.borderStyle = "dotted";
          const dataAt = node2.getAttribute("data-at") || "", dataIn = node2.getAttribute("data-in") || "", tooltip = document.createElement("span");
          tooltip.style.position = "absolute", tooltip.style.top = "0px", tooltip.style.left = "0px", tooltip.style.padding = "3px", tooltip.style.background = "rgba(0,0,0,0.75)", tooltip.style.color = "rgba(255,255,255,1)", tooltip.style.fontSize = "12px", tooltip.style.lineHeight = "12px", tooltip.style.fontFamily = "monospace", tooltip.style.webkitFontSmoothing = "none", tooltip.innerText = `${componentName2 || ""} ${dataAt} ${dataIn}`.trim(), overlay.appendChild(tooltip), node2.appendChild(overlay);
        } else overlay && node2.removeChild(overlay);
      };
      return debugKeyListeners || (debugKeyListeners = /* @__PURE__ */ new Set()), debugKeyListeners.add(debugVisualizerHandler), () => {
        debugKeyListeners == null ? void 0 : debugKeyListeners.delete(debugVisualizerHandler);
      };
    }, [componentName2]);
    const animationDriver = componentContext.animationDriver, useAnimations = animationDriver == null ? void 0 : animationDriver.useAnimations, {
      curStateRef,
      disabled,
      groupName,
      hasAnimationProp,
      hasEnterStyle,
      isAnimated,
      isExiting,
      isHydrated,
      presence,
      presenceState,
      setState,
      setStateShallow,
      noClass,
      state,
      stateRef,
      supportsCSSVars,
      willBeAnimated,
      willBeAnimatedClient
    } = useComponentState(props, componentContext, staticConfig, config);
    time2 && time2`use-state`;
    const hasTextAncestor = !!(isWeb && isText && componentContext.inText), isTaggable = !Component || typeof Component == "string", tagProp = props.tag, element = isWeb && isTaggable && tagProp || Component;
    let elementType = isText ? BaseText || element || "span" : BaseView || element || (hasTextAncestor ? "span" : "div");
    animationDriver && isAnimated && (elementType = animationDriver[isText ? "Text" : "View"] || elementType);
    const disableTheme = props["data-disable-theme"] || isHOC;
    time2 && time2`theme-props`, props.themeShallow && (curStateRef.themeShallow = true);
    const themeStateProps = {
      componentName: componentName2,
      disable: disableTheme,
      shallow: curStateRef.themeShallow,
      debug: debugProp
    };
    if ("themeInverse" in props && (themeStateProps.inverse = props.themeInverse), "theme" in props && (themeStateProps.name = props.theme), typeof curStateRef.isListeningToTheme == "boolean" && (themeStateProps.needsUpdate = () => !!stateRef.current.isListeningToTheme), debugProp && debugProp !== "profile") {
      const name = `${componentName2 || (Component == null ? void 0 : Component.displayName) || (Component == null ? void 0 : Component.name) || "[Unnamed Component]"}`, type = (hasEnterStyle ? "(hasEnter)" : " ") + (isAnimated ? "(animated)" : " ") + (isReactNative ? "(rnw)" : " ") + (noClass ? "(noClass)" : " ") + (state.press || state.pressIn ? "(PRESSED)" : " ") + (state.hover ? "(HOVERED)" : " ") + (state.focus ? "(FOCUSED)" : " ") + (state.focusWithin ? "(WITHIN FOCUSED)" : " ") + ((presenceState == null ? void 0 : presenceState.isPresent) === false ? "(EXIT)" : ""), dataIs = propsIn["data-is"] || "", banner = `${internalID} ${name}${dataIs ? ` ${dataIs}` : ""} ${type}`;
      if (console.info(`%c ${banner} (hydrated: ${isHydrated}) (unmounted: ${state.unmounted})`, "background: green; color: white;"), isServer) log({
        noClass,
        isAnimated,
        isWeb,
        supportsCSSVars
      });
      else {
        groupEnd();
        const ch = propsIn.children;
        let childLog = typeof ch == "string" ? ch.length > 4 ? ch.slice(0, 4) + "..." : ch : "";
        childLog.length && (childLog = `(children: ${childLog})`), groupCollapsed(`${childLog} Props:`), log("props in:", propsIn), log("final props:", props), log({
          state,
          staticConfig,
          elementType,
          themeStateProps
        }), log({
          contextProps: styledContextProps,
          overriddenContextProps
        }), log({
          presence,
          isAnimated,
          isHOC,
          hasAnimationProp,
          useAnimations
        }), groupEnd();
      }
    }
    time2 && time2`pre-theme-media`;
    const [theme, themeState] = useThemeWithState(themeStateProps);
    time2 && time2`theme`, elementType = Component || elementType;
    const isStringElement = typeof elementType == "string", mediaState2 = useMedia(componentContext, debugProp);
    setDidGetVariableValue(false), time2 && time2`media`;
    const resolveValues = (
      // if HOC + mounted + has animation prop, resolve as value so it passes non-variable to child
      isAnimated && !supportsCSSVars || isHOC && state.unmounted == false && hasAnimationProp ? "value" : "auto"
    ), styleProps = {
      mediaState: mediaState2,
      noClass,
      resolveValues,
      isExiting,
      isAnimated,
      willBeAnimated,
      styledContextProps
    }, themeName = (themeState == null ? void 0 : themeState.name) || "";
    time2 && time2`split-styles-prepare`;
    const splitStyles = useSplitStyles(props, staticConfig, theme, themeName, state, styleProps, null, componentContext, elementType, debugProp);
    time2 && time2`split-styles`, props.group && props.untilMeasured === "hide" && !curStateRef.hasMeasured && (splitStyles.style || (splitStyles.style = {}), splitStyles.style.opacity = 0), curStateRef.isListeningToTheme = splitStyles.dynamicThemeAccess;
    const hasRuntimeMediaKeys = splitStyles.hasMedia && splitStyles.hasMedia !== true, shouldListenForMedia = didGetVariableValue() || hasRuntimeMediaKeys || noClass && splitStyles.hasMedia === true, mediaListeningKeys = hasRuntimeMediaKeys ? splitStyles.hasMedia : null;
    debugProp === "verbose" && console.info("useMedia() createComponent", shouldListenForMedia, mediaListeningKeys), setMediaShouldUpdate(componentContext, shouldListenForMedia, mediaListeningKeys);
    const {
      viewProps: viewPropsIn,
      pseudos,
      style: splitStylesStyle,
      classNames,
      space
    } = splitStyles, propsWithAnimation = props, {
      asChild,
      children,
      themeShallow,
      spaceDirection: _spaceDirection,
      onPress,
      onLongPress,
      onPressIn,
      onPressOut,
      onHoverIn,
      onHoverOut,
      onMouseUp,
      onMouseDown,
      onMouseEnter,
      onMouseLeave,
      onFocus,
      onBlur,
      separator,
      // ignore from here on out
      forceStyle: _forceStyle,
      // @ts-ignore  for next/link compat etc
      onClick,
      theme: _themeProp,
      ...nonTamaguiProps
    } = viewPropsIn;
    let viewProps = nonTamaguiProps;
    !isTaggable && props.forceStyle && (viewProps.forceStyle = props.forceStyle), isHOC && _themeProp && (viewProps.theme = _themeProp), tagProp && elementType.acceptTagProp && (viewProps.tag = tagProp);
    let animationStyles;
    if (
      // if it supports css vars we run it on server too to get matching initial style
      (supportsCSSVars ? willBeAnimatedClient : willBeAnimated) && useAnimations && !isHOC
    ) {
      const animations = useAnimations({
        props: propsWithAnimation,
        // if hydrating, send empty style
        style: splitStylesStyle || {},
        presence,
        componentState: state,
        styleProps,
        theme,
        pseudos: pseudos || null,
        staticConfig,
        stateRef
      });
      (isAnimated || supportsCSSVars) && animations && (animationStyles = animations.style, viewProps.style = animationStyles, animations.className && (viewProps.className = `${state.unmounted === "should-enter" ? "t_unmounted " : ""}${viewProps.className || ""} ${animations.className}`)), time2 && time2`animations`;
    }
    props.untilMeasured && !props.group && console.warn(`You set the untilMeasured prop without setting group. This doesn't work, be sure to set untilMeasured on the parent that sets group, not the children that use the $group- prop.

If you meant to do this, you can disable this warning - either change untilMeasured and group at the same time, or do group={conditional ? 'name' : undefined}`), time2 && time2`destructure`, groupName && (nonTamaguiProps.onLayout = composeEventHandlers(nonTamaguiProps.onLayout, (e) => {
      const layout = e.nativeEvent.layout;
      stateRef.current.group.layout = layout, stateRef.current.group.emit(groupName, {
        layout
      }), !stateRef.current.hasMeasured && props.untilMeasured === "hide" && setState((prev) => ({
        ...prev
      })), stateRef.current.hasMeasured = true;
    })), viewProps = ((_c = (_b = hooks).usePropsTransform) == null ? void 0 : _c.call(_b, elementType, nonTamaguiProps, stateRef, curStateRef.willHydrate)) || nonTamaguiProps, curStateRef.composedRef || (curStateRef.composedRef = composeRefs((x) => stateRef.current.host = x, forwardedRef, setElementProps)), viewProps.ref = curStateRef.composedRef, !isReactNative && !isText && isWeb && !isHOC && import_react14.default.Children.toArray(props.children).forEach((item) => {
      typeof item == "string" && item !== `
` && console.error(`Unexpected text node: ${item}. A text node cannot be a child of a <${staticConfig.componentName || propsIn.tag || "View"}>.`, props);
    }), time2 && time2`events-hooks`;
    const {
      pseudoGroups,
      mediaGroups
    } = splitStyles, unPress = () => setStateShallow({
      press: false,
      pressIn: false
    });
    isWeb && useIsomorphicLayoutEffect(() => {
      if (debugProp === "verbose") {
        const computed = function(style) {
          const styleObject = {};
          for (let i = 0; i < style.length; i++) {
            let prop = style[i];
            styleObject[prop] = style.getPropertyValue(prop);
          }
          return styleObject;
        }(getComputedStyle(stateRef.current.host));
        groupCollapsed(`Rendered > (opacity: ${computed.opacity})`), console.warn(stateRef.current.host), console.warn(computed), groupEnd();
      }
    }), useIsomorphicLayoutEffect(() => {
      if (disabled) return;
      if (state.unmounted === true && hasEnterStyle) {
        setStateShallow({
          unmounted: "should-enter"
        });
        return;
      }
      if (state.unmounted) {
        setStateShallow({
          unmounted: false
        });
        return;
      }
      const dispose2 = pseudoGroups || mediaGroups ? subscribeToContextGroup({
        componentContext,
        setStateShallow,
        state,
        mediaGroups,
        pseudoGroups
      }) : null;
      return () => {
        dispose2 == null ? void 0 : dispose2(), componentSetStates.delete(setState);
      };
    }, [state.unmounted, disabled, pseudoGroups ? Object.keys([...pseudoGroups]).join("") : 0, mediaGroups ? Object.keys([...mediaGroups]).join("") : 0]), useIsomorphicLayoutEffect(() => {
      var _a4;
      if (!groupName) return;
      curStateRef.group.emit(groupName, {
        pseudo: state,
        layout: (_a4 = curStateRef.group) == null ? void 0 : _a4.layout
      });
      const groupContextState = componentContext == null ? void 0 : componentContext.groups;
      if (groupContextState) {
        const next = {
          ...groupContextState[groupName],
          ...state
        };
        groupContextState[groupName] = next;
      }
    }, [groupName, state]);
    const runtimePressStyle = !disabled && noClass && (pseudos == null ? void 0 : pseudos.pressStyle), runtimeFocusStyle = !disabled && noClass && (pseudos == null ? void 0 : pseudos.focusStyle), runtimeFocusVisibleStyle = !disabled && noClass && (pseudos == null ? void 0 : pseudos.focusVisibleStyle), attachFocus = !!(runtimePressStyle || runtimeFocusStyle || runtimeFocusVisibleStyle || onFocus || onBlur || componentContext.setParentFocusState), attachPress = !!(groupName || runtimePressStyle || onPress || onPressOut || onPressIn || onMouseDown || onMouseUp || onLongPress || onClick || (pseudos == null ? void 0 : pseudos.focusVisibleStyle)), runtimeHoverStyle = !disabled && noClass && (pseudos == null ? void 0 : pseudos.hoverStyle), needsHoverState = !!(groupName || runtimeHoverStyle || onHoverIn || onHoverOut), attachHover = isWeb && !!(groupName || needsHoverState || onMouseEnter || onMouseLeave), shouldAttach = !disabled && !props.asChild && !!(attachFocus || attachPress || attachHover || runtimePressStyle || runtimeHoverStyle || runtimeFocusStyle), needsPressState = !!(groupName || runtimePressStyle);
    time2 && time2`events-setup`, debugProp === "verbose" && log("🪩 events()", {
      runtimeFocusStyle,
      runtimePressStyle,
      runtimeHoverStyle,
      runtimeFocusVisibleStyle,
      attachPress,
      attachFocus,
      attachHover,
      shouldAttach,
      needsHoverState,
      pseudos
    });
    const events = shouldAttach ? {
      onPressOut: attachPress ? (e) => {
        unPress(), onPressOut == null ? void 0 : onPressOut(e), onMouseUp == null ? void 0 : onMouseUp(e);
      } : void 0,
      ...(attachHover || attachPress) && {
        onMouseEnter: (e) => {
          const next = {};
          needsHoverState && (next.hover = true), needsPressState && state.pressIn && (next.press = true), setStateShallow(next), onHoverIn == null ? void 0 : onHoverIn(e), onMouseEnter == null ? void 0 : onMouseEnter(e);
        },
        onMouseLeave: (e) => {
          const next = {};
          needsHoverState && (next.hover = false), needsPressState && state.pressIn && (next.press = false, next.pressIn = false), setStateShallow(next), onHoverOut == null ? void 0 : onHoverOut(e), onMouseLeave == null ? void 0 : onMouseLeave(e);
        }
      },
      onPressIn: attachPress ? (e) => {
        (runtimePressStyle || groupName) && setStateShallow({
          press: true,
          pressIn: true
        }), onPressIn == null ? void 0 : onPressIn(e), onMouseDown == null ? void 0 : onMouseDown(e), isWeb && componentSetStates.add(setState);
      } : void 0,
      onPress: attachPress ? (e) => {
        unPress(), isWeb && (onClick == null ? void 0 : onClick(e)), onPress == null ? void 0 : onPress(e), onLongPress == null ? void 0 : onLongPress(e);
      } : void 0,
      ...attachFocus && {
        onFocus: (e) => {
          componentContext.setParentFocusState && componentContext.setParentFocusState({
            focusWithin: true
          }), (pseudos == null ? void 0 : pseudos.focusVisibleStyle) ? setTimeout(() => {
            setStateShallow({
              focus: true,
              focusVisible: !!lastInteractionWasKeyboard.value
            });
          }, 0) : setStateShallow({
            focus: true,
            focusVisible: false
          }), onFocus == null ? void 0 : onFocus(e);
        },
        onBlur: (e) => {
          componentContext.setParentFocusState && componentContext.setParentFocusState({
            focusWithin: false
          }), setStateShallow({
            focus: false,
            focusVisible: false
          }), onBlur == null ? void 0 : onBlur(e);
        }
      }
    } : null;
    events && !isReactNative && Object.assign(viewProps, getWebEvents(events)), time2 && time2`events`, debugProp === "verbose" && log("events", {
      events,
      attachHover,
      attachPress
    }), (_e = (_d = hooks).useEvents) == null ? void 0 : _e.call(_d, viewProps, events, splitStyles, setStateShallow, staticConfig);
    const direction = props.spaceDirection || "both";
    time2 && time2`hooks`;
    let content = !children || asChild ? children : spacedChildren({
      separator,
      children,
      space,
      direction,
      isZStack,
      debug: debugProp
    });
    if (asChild) {
      elementType = Slot;
      {
        const passEvents = getWebEvents({
          onPress,
          onLongPress,
          onPressIn,
          onPressOut,
          onMouseUp,
          onMouseDown,
          onMouseEnter,
          onMouseLeave
        }, asChild === "web" || asChild === "except-style-web");
        Object.assign(viewProps, passEvents);
      }
    }
    time2 && time2`spaced-as-child`;
    let useChildrenResult;
    hooks.useChildren && (useChildrenResult = hooks.useChildren(elementType, content, viewProps)), time2 && time2`use-children`, useChildrenResult ? content = useChildrenResult : content = import_react14.default.createElement(elementType, viewProps, content);
    const ResetPresence = (_f = config == null ? void 0 : config.animations) == null ? void 0 : _f.ResetPresence;
    ResetPresence && willBeAnimated && (hasEnterStyle || presenceState) && content && typeof content != "string" && (content = (0, import_jsx_runtime7.jsx)(ResetPresence, {
      children: content
    })), time2 && time2`create-element`;
    const groupState = curStateRef.group, subGroupContext = import_react14.default.useMemo(() => {
      var _a4, _b2;
      if (!(!groupState || !groupName)) return groupState.listeners.clear(), {
        ...componentContext.groups,
        // change reference so as we mutate it doesn't affect siblings etc
        state: {
          ...componentContext.groups.state,
          [groupName]: {
            pseudo: defaultComponentStateMounted,
            // capture just initial width and height if they exist
            // will have top, left, width, height (not x, y)
            layout: {
              width: fromPx((_a4 = splitStyles.style) == null ? void 0 : _a4.width),
              height: fromPx((_b2 = splitStyles.style) == null ? void 0 : _b2.height)
            }
          }
        },
        emit: groupState.emit,
        subscribe: groupState.subscribe
      };
    }, [groupName]);
    if (("group" in props || propsIn.focusWithinStyle) && (content = (0, import_jsx_runtime7.jsx)(ComponentContext.Provider, {
      ...componentContext,
      groups: subGroupContext,
      setParentFocusState: setStateShallow,
      children: content
    })), time2 && time2`group-context`, content = disableTheme ? content : getThemedChildren(themeState, content, themeStateProps, false, stateRef), time2 && time2`themed-children`, isReactNative && !asChild && (content = (0, import_jsx_runtime7.jsx)("span", {
      className: "_dsp_contents",
      ...isHydrated && events && getWebEvents(events),
      children: content
    })), staticConfig.context) {
      const contextProps = staticConfig.context.props;
      for (const key in contextProps) (viewProps.style && key in viewProps.style || key in viewProps) && (overriddenContextProps || (overriddenContextProps = {}), overriddenContextProps[key] = ((_g = viewProps.style) == null ? void 0 : _g[key]) ?? viewProps[key]);
    }
    if (overriddenContextProps) {
      const Provider = staticConfig.context.Provider;
      content = (0, import_jsx_runtime7.jsx)(Provider, {
        ...contextValue,
        ...overriddenContextProps,
        children: content
      });
    }
    const {
      rulesToInsert
    } = splitStyles;
    if (process.env.TAMAGUI_REACT_19 && (content = wrapStyleTags(Object.values(rulesToInsert), content)), debugProp && debugProp !== "profile") {
      const title = `render <${typeof elementType == "string" ? elementType : "Component"} /> (${internalID}) with props`;
      if (isWeb) {
        groupCollapsed(title);
        try {
          log("viewProps", viewProps), log("children", content), typeof window < "u" && log({
            propsIn,
            props,
            animationStyles,
            classNames,
            content,
            defaultProps,
            elementType,
            events,
            isAnimated,
            hasRuntimeMediaKeys,
            isStringElement,
            mediaListeningKeys,
            pseudos,
            shouldAttach,
            noClass,
            shouldListenForMedia,
            splitStyles,
            splitStylesStyle,
            state,
            stateRef,
            staticConfig,
            styleProps,
            themeState,
            viewProps,
            willBeAnimated
          });
        } catch {
        } finally {
          groupEnd();
        }
      } else {
        log(title), log("state: ", state), isDevTools && log("viewProps", viewProps), log("final styles:");
        for (const key in splitStylesStyle) log(key, splitStylesStyle[key]);
      }
      if (debugProp === "break") debugger;
    }
    return time2 && (time2`rest`, globalThis.willPrint || (globalThis.willPrint = true, setTimeout(() => {
      delete globalThis.willPrint, time2.print(), time2 = null;
    }, 50))), content;
  });
  staticConfig.componentName && (component.displayName = staticConfig.componentName);
  let res = component;
  (process.env.TAMAGUI_FORCE_MEMO || staticConfig.memo) && (res = import_react14.default.memo(res)), res.staticConfig = staticConfig;
  function extendStyledConfig(extended) {
    return {
      ...staticConfig,
      ...extended,
      neverFlatten: true,
      isHOC: true,
      isStyledHOC: false
    };
  }
  function extractable(Component2, extended) {
    return Component2.staticConfig = extendStyledConfig(extended), Component2.styleable = styleable, Component2;
  }
  function styleable(Component2, options) {
    var _a3;
    let out = ((_a3 = Component2.render) == null ? void 0 : _a3.length) === 2 ? Component2 : import_react14.default.forwardRef(Component2);
    const extendedConfig = extendStyledConfig(options == null ? void 0 : options.staticConfig);
    return out = (options == null ? void 0 : options.disableTheme) ? out : themeable(out, extendedConfig, true), process.env.TAMAGUI_MEMOIZE_STYLEABLE && (out = import_react14.default.memo(out)), out.staticConfig = extendedConfig, out.styleable = styleable, out;
  }
  return res.extractable = extractable, res.styleable = styleable, res;
}
function getWebEvents(events, webStyle = true) {
  return {
    onMouseEnter: events.onMouseEnter,
    onMouseLeave: events.onMouseLeave,
    [webStyle ? "onClick" : "onPress"]: events.onPress,
    onMouseDown: events.onPressIn,
    onMouseUp: events.onPressOut,
    onTouchStart: events.onPressIn,
    onTouchEnd: events.onPressOut,
    onFocus: events.onFocus,
    onBlur: events.onBlur
  };
}
function Unspaced(props) {
  return props.children;
}
Unspaced.isUnspaced = true;
var getSpacerSize = (size, {
  tokens
}) => {
  size = size === true ? "$true" : size;
  const sizePx = tokens.space[size] ?? size;
  return {
    width: sizePx,
    height: sizePx,
    minWidth: sizePx,
    minHeight: sizePx
  };
};
var Spacer = createComponent({
  acceptsClassName: true,
  memo: true,
  componentName: "Spacer",
  validStyles,
  defaultProps: {
    ...stackDefaultStyles,
    // avoid nesting issues
    tag: "span",
    size: true,
    pointerEvents: "none"
  },
  variants: {
    size: {
      "...": getSpacerSize
    },
    flex: {
      true: {
        flexGrow: 1
      }
    },
    direction: {
      horizontal: {
        height: 0,
        minHeight: 0
      },
      vertical: {
        width: 0,
        minWidth: 0
      },
      both: {}
    }
  }
});
function spacedChildren(props) {
  var _a2, _b, _c;
  const {
    isZStack,
    children,
    space,
    direction,
    spaceFlex,
    separator,
    ensureKeys
  } = props, hasSpace = !!(space || spaceFlex), hasSeparator = separator != null, areChildrenArray = Array.isArray(children);
  if (!ensureKeys && !(hasSpace || hasSeparator || isZStack)) return children;
  const childrenList = areChildrenArray ? children : import_react14.default.Children.toArray(children);
  if (childrenList.length <= 1 && !isZStack && !((_b = (_a2 = childrenList[0]) == null ? void 0 : _a2.type) == null ? void 0 : _b.shouldForwardSpace)) return children;
  const final = [];
  for (let [index, child] of childrenList.entries()) {
    const isEmpty = child == null || Array.isArray(child) && child.length === 0;
    if (!isEmpty && import_react14.default.isValidElement(child) && ((_c = child.type) == null ? void 0 : _c.shouldForwardSpace) && (child = import_react14.default.cloneElement(child, {
      space,
      spaceFlex,
      separator,
      key: child.key
    })), isEmpty || !child || child.key && !isZStack ? final.push(child) : final.push((0, import_jsx_runtime7.jsx)(import_react14.default.Fragment, {
      children: isZStack ? (0, import_jsx_runtime7.jsx)(AbsoluteFill, {
        children: child
      }) : child
    }, `${index}0t`)), isUnspaced(child) && index === 0 || isZStack) continue;
    const next = childrenList[index + 1];
    next && !isEmpty && !isUnspaced(next) && (separator ? (hasSpace && final.push(createSpacer({
      key: `_${index}_00t`,
      direction,
      space,
      spaceFlex
    })), final.push((0, import_jsx_runtime7.jsx)(import_react14.default.Fragment, {
      children: separator
    }, `${index}03t`)), hasSpace && final.push(createSpacer({
      key: `_${index}01t`,
      direction,
      space,
      spaceFlex
    }))) : final.push(createSpacer({
      key: `_${index}02t`,
      direction,
      space,
      spaceFlex
    })));
  }
  return props.debug && log("  Spaced children", final, props), final;
}
function createSpacer({
  key,
  direction,
  space,
  spaceFlex
}) {
  return (0, import_jsx_runtime7.jsx)(Spacer, {
    size: space,
    direction,
    ...typeof spaceFlex < "u" && {
      flex: spaceFlex === true ? 1 : spaceFlex === false ? 0 : spaceFlex
    }
  }, key);
}
function isUnspaced(child) {
  const t = child == null ? void 0 : child.type;
  return (t == null ? void 0 : t.isVisuallyHidden) || (t == null ? void 0 : t.isUnspaced);
}
var AbsoluteFill = createComponent({
  defaultProps: {
    ...stackDefaultStyles,
    flexDirection: "column",
    position: "absolute",
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    pointerEvents: "box-none"
  }
});
var fromPx = (val) => typeof val != "string" ? val : +val.replace("px", "");

// node_modules/@tamagui/web/dist/esm/createShorthands.mjs
function createShorthands(shorthands) {
  return Object.freeze(shorthands);
}

// node_modules/@tamagui/web/dist/esm/createTheme.mjs
var createTheme = (theme) => theme;

// node_modules/@tamagui/web/dist/esm/createFont.mjs
var fontWeights = ["100", "200", "300", "400", "500", "600", "700", "800", "900"];
var processSection = (section, keys, defaultValue2) => {
  if (typeof section == "string") return section;
  const sectionKeys = Object.keys(section);
  let fillValue = section[sectionKeys[0]];
  return Object.fromEntries([.../* @__PURE__ */ new Set([...keys, ...sectionKeys])].map((key) => {
    const value = section[key] ?? defaultValue2 ?? fillValue;
    return fillValue = value, defaultValue2 = value, [key, value];
  }));
};
var createFont = (font) => {
  const sizeKeys = Object.keys(font.size || {}), processedFont = Object.fromEntries(Object.entries(font).map(([key, section]) => [key, processSection(section, key === "face" ? fontWeights : sizeKeys, key === "face" ? {
    normal: font.family
  } : void 0)]));
  return Object.freeze(processedFont);
};

// node_modules/@tamagui/web/dist/esm/createVariables.mjs
var cache6 = /* @__PURE__ */ new WeakMap();
var createVariables = (tokens, parentPath = "", isFont = false) => {
  if (cache6.has(tokens)) return tokens;
  const res = {};
  let i = 0;
  for (let keyIn in tokens) {
    i++;
    const val = tokens[keyIn], isPrefixed = keyIn[0] === "$", keyWithPrefix = isPrefixed ? keyIn : `$${keyIn}`, key = isPrefixed ? keyWithPrefix.slice(1) : keyIn;
    if (isVariable(val)) {
      res[key] = val;
      continue;
    }
    const niceKey = simpleHash(key, 1e3), name = parentPath && parentPath !== "t-color" ? `${parentPath}-${niceKey}` : `c-${niceKey}`;
    if (val && typeof val == "object") {
      res[key] = createVariables(
        tokens[key],
        name,
        false
        /* note: don't pass isFont down, we want to avoid it past the first level */
      );
      continue;
    }
    const finalValue = isVariable(val) ? val : createVariable({
      val,
      name,
      key: keyWithPrefix
    });
    res[key] = finalValue;
  }
  return cache6.set(res, true), res;
};

// node_modules/@tamagui/web/dist/esm/helpers/registerCSSVariable.mjs
var registerCSSVariable = (v) => {
  tokensValueToVariable.set(getVariableValue(v), v);
};
var variableToCSS = (v, unitless = false) => `--${process.env.TAMAGUI_CSS_VARIABLE_PREFIX || ""}${createCSSVariable(v.name, false)}:${!unitless && typeof v.val == "number" ? `${v.val}px` : v.val}`;
var tokensValueToVariable = /* @__PURE__ */ new Map();

// node_modules/@tamagui/web/dist/esm/insertFont.mjs
function insertFont(name, fontIn) {
  const font = createFont(fontIn), tokened = createVariables(font, name), parsed = parseFont(tokened);
  if (typeof document < "u") {
    const fontVars = registerFontVariables(parsed), styleElement = document.querySelector(`style[${FONT_DATA_ATTRIBUTE_NAME}="${name}"]`) || document.createElement("style");
    styleElement.innerText = `:root .font_${name} {${fontVars.join(";")}}`, styleElement.setAttribute(FONT_DATA_ATTRIBUTE_NAME, name), document.head.appendChild(styleElement);
  }
  return setConfigFont(name, tokened, parsed), parsed;
}
function parseFont(definition) {
  var _a2;
  const parsed = {};
  for (const attrKey in definition) {
    const attr = definition[attrKey];
    if (attrKey === "family" || attrKey === "face") parsed[attrKey] = attr;
    else {
      parsed[attrKey] = {};
      for (const key in attr) {
        let val = attr[key];
        ((_a2 = val.val) == null ? void 0 : _a2[0]) === "$" && (val = val.val), parsed[attrKey][`$${key}`] = val;
      }
    }
  }
  return parsed;
}
function registerFontVariables(parsedFont) {
  const response = [];
  for (const fkey in parsedFont) if (fkey !== "face") {
    if (fkey === "family") {
      const val = parsedFont[fkey];
      registerCSSVariable(val), response.push(variableToCSS(val));
    } else for (const fskey in parsedFont[fkey]) if (typeof parsedFont[fkey][fskey] != "string") {
      const val = parsedFont[fkey][fskey];
      registerCSSVariable(val), response.push(variableToCSS(val));
    }
  }
  return response;
}

// node_modules/@tamagui/web/dist/esm/createTokens.mjs
function createTokens(tokens) {
  return createVariables(tokens, process.env.TAMAGUI_TOKEN_PREFIX ?? "t");
}

// node_modules/@tamagui/web/dist/esm/setupReactNative.mjs
var ReactNativeStaticConfigs = /* @__PURE__ */ new WeakMap();
function getReactNativeConfig(Component) {
  var _a2;
  if (Component) return Component.getSize && Component.prefetch ? RNConfigs.Image : Component.displayName === "Text" && Component.render ? RNConfigs.Text : Component.render && (Component.displayName === "ScrollView" || Component.displayName === "View") ? RNConfigs.default : ((_a2 = Component.State) == null ? void 0 : _a2.blurTextInput) ? RNConfigs.TextInput : ReactNativeStaticConfigs.get(Component);
}
var RNConfigs = {
  Image: {
    isReactNative: true,
    inlineProps: /* @__PURE__ */ new Set(["src", "width", "height"])
  },
  Text: {
    isReactNative: true,
    isText: true
  },
  TextInput: {
    isReactNative: true,
    isInput: true,
    isText: true
  },
  default: {
    isReactNative: true
  }
};
function setupReactNative(rnExports) {
}

// node_modules/@tamagui/web/dist/esm/helpers/mergeVariants.mjs
var mergeVariants = (parentVariants, ourVariants, level = 0) => {
  const variants = {};
  for (const key in ourVariants) {
    const parentVariant = parentVariants == null ? void 0 : parentVariants[key], ourVariant = ourVariants[key];
    !parentVariant || typeof ourVariant == "function" ? variants[key] = ourVariant : parentVariant && !ourVariant ? variants[key] = parentVariant[key] : level === 0 ? variants[key] = mergeVariants(parentVariant, ourVariant, level + 1) : variants[key] = {
      ...parentVariant,
      ...ourVariant
    };
  }
  return {
    ...parentVariants,
    ...variants
  };
};

// node_modules/@tamagui/web/dist/esm/styled.mjs
function styled(ComponentIn, options, staticExtractionOptions) {
  if (!ComponentIn) throw new Error("No component given to styled()");
  const parentStaticConfig = ComponentIn.staticConfig, isPlainStyledComponent = !!parentStaticConfig && !(parentStaticConfig.isReactNative || parentStaticConfig.isHOC);
  let Component = (parentStaticConfig == null ? void 0 : parentStaticConfig.isHOC) && !(parentStaticConfig == null ? void 0 : parentStaticConfig.isStyledHOC) || isPlainStyledComponent ? ComponentIn : (parentStaticConfig == null ? void 0 : parentStaticConfig.Component) || ComponentIn;
  const reactNativeConfig = parentStaticConfig ? void 0 : getReactNativeConfig(Component), isReactNative = !!(reactNativeConfig || (staticExtractionOptions == null ? void 0 : staticExtractionOptions.isReactNative) || (parentStaticConfig == null ? void 0 : parentStaticConfig.isReactNative)), staticConfigProps = (() => {
    let {
      variants,
      name,
      defaultVariants,
      acceptsClassName: acceptsClassNameProp,
      context,
      ...defaultProps
    } = options || {}, parentDefaultVariants, parentDefaultProps;
    if (parentStaticConfig && !(parentStaticConfig.isHOC && !parentStaticConfig.isStyledHOC)) {
      const pdp = parentStaticConfig.defaultProps;
      for (const key in pdp) {
        const val = pdp[key];
        parentStaticConfig.defaultVariants && key in parentStaticConfig.defaultVariants && (!defaultVariants || !(key in defaultVariants)) && (parentDefaultVariants || (parentDefaultVariants = {}), parentDefaultVariants[key] = val), !(key in defaultProps) && (!defaultVariants || !(key in defaultVariants)) && (parentDefaultProps || (parentDefaultProps = {}), parentDefaultProps[key] = pdp[key]);
      }
      parentStaticConfig.variants && (variants = mergeVariants(parentStaticConfig.variants, variants));
    }
    (parentDefaultProps || defaultVariants || parentDefaultVariants) && (defaultProps = {
      ...parentDefaultProps,
      ...parentDefaultVariants,
      ...defaultProps,
      ...defaultVariants
    }), (parentStaticConfig == null ? void 0 : parentStaticConfig.isHOC) && name && (defaultProps.componentName = name);
    const isText = !!((staticExtractionOptions == null ? void 0 : staticExtractionOptions.isText) || (parentStaticConfig == null ? void 0 : parentStaticConfig.isText)), acceptsClassName = (staticExtractionOptions == null ? void 0 : staticExtractionOptions.acceptsClassName) ?? acceptsClassNameProp ?? (isPlainStyledComponent || isReactNative || (parentStaticConfig == null ? void 0 : parentStaticConfig.isHOC) && (parentStaticConfig == null ? void 0 : parentStaticConfig.acceptsClassName)), conf4 = {
      ...parentStaticConfig,
      ...staticExtractionOptions,
      ...!isPlainStyledComponent && {
        Component
      },
      // @ts-expect-error
      variants,
      defaultProps,
      defaultVariants,
      componentName: name || (parentStaticConfig == null ? void 0 : parentStaticConfig.componentName),
      isReactNative,
      isText,
      acceptsClassName,
      context,
      ...reactNativeConfig,
      isStyledHOC: !!(parentStaticConfig == null ? void 0 : parentStaticConfig.isHOC),
      parentStaticConfig
    };
    return (defaultProps.children || !acceptsClassName || context) && (conf4.neverFlatten = true), conf4;
  })(), component = createComponent(staticConfigProps || {});
  for (const key in ComponentIn) key !== "propTypes" && (key in component || (component[key] = ComponentIn[key]));
  return component;
}

// node_modules/@tamagui/web/dist/esm/helpers/isTamaguiComponent.mjs
function isTamaguiComponent(comp, name) {
  const config = comp == null ? void 0 : comp.staticConfig;
  return !!(config && (!name || name === config.componentName));
}

// node_modules/@tamagui/web/dist/esm/helpers/isTamaguiElement.mjs
var import_react15 = __toESM(require_react(), 1);
var isTamaguiElement = (child, name) => import_react15.default.isValidElement(child) && isTamaguiComponent(child.type, name);

// node_modules/@tamagui/web/dist/esm/hooks/useThemeName.mjs
var forceUpdateState = {
  forceClassName: true,
  deopt: true,
  needsUpdate: () => true
};
var forceKeys = {
  current: /* @__PURE__ */ new Set([""])
};
function useThemeName() {
  var _a2;
  return ((_a2 = useThemeState(forceUpdateState, false, forceKeys)) == null ? void 0 : _a2.name) || "";
}

// node_modules/@tamagui/web/dist/esm/hooks/useConfiguration.mjs
var import_react16 = __toESM(require_react(), 1);
var useConfiguration = () => {
  const {
    groups,
    animationDriver,
    ...restComponentConfig
  } = import_react16.default.useContext(ComponentContext), {
    animations,
    ...restConfig
  } = getConfig();
  return {
    ...restConfig,
    ...restComponentConfig,
    animationDriver: animationDriver ?? getConfig().animations
  };
};

// node_modules/@tamagui/web/dist/esm/hooks/useIsTouchDevice.mjs
var useIsTouchDevice = () => isWeb ? useDidFinishSSR() ? isTouchable : false : true;

// node_modules/@tamagui/web/dist/esm/hooks/useProps.mjs
var import_react17 = __toESM(require_react(), 1);

// node_modules/@tamagui/web/dist/esm/views/Stack.mjs
var Stack = createComponent({
  acceptsClassName: true,
  defaultProps: stackDefaultStyles,
  validStyles
});
Stack.displayName = "Stack";

// node_modules/@tamagui/web/dist/esm/hooks/useProps.mjs
function useProps(props, opts) {
  const [propsOut, styleOut] = usePropsAndStyle(props, {
    ...opts,
    noExpand: true,
    noNormalize: true,
    resolveValues: "none"
  });
  return {
    ...propsOut,
    ...styleOut
  };
}
function useStyle(props, opts) {
  return usePropsAndStyle(props, opts)[1] || {};
}
function usePropsAndStyle(props, opts) {
  var _a2;
  const staticConfig = ((_a2 = opts == null ? void 0 : opts.forComponent) == null ? void 0 : _a2.staticConfig) ?? Stack.staticConfig, [theme, themeState] = useThemeWithState({
    componentName: staticConfig.componentName,
    name: "theme" in props ? props.theme : void 0,
    inverse: "themeInverse" in props ? props.themeInverse : void 0,
    needsUpdate() {
      return true;
    }
  }), componentContext = import_react17.default.useContext(ComponentContext), {
    state,
    disabled,
    setStateShallow
  } = useComponentState(props, componentContext, staticConfig, getConfig()), mediaStateNow = (opts == null ? void 0 : opts.noMedia) ? (
    // not safe to use mediaState but really marginal to hit this
    mediaState
  ) : useMedia(), splitStyles = useSplitStyles(props, staticConfig, theme, (themeState == null ? void 0 : themeState.name) || "", state, {
    isAnimated: false,
    mediaState: mediaStateNow,
    noSkip: true,
    noMergeStyle: true,
    noClass: true,
    resolveValues: "auto",
    ...opts
  }, null, componentContext), {
    mediaGroups,
    pseudoGroups
  } = splitStyles;
  return useIsomorphicLayoutEffect(() => {
    if (!disabled) {
      if (state.unmounted) {
        setStateShallow({
          unmounted: false
        });
        return;
      }
      return subscribeToContextGroup({
        componentContext,
        setStateShallow,
        state,
        mediaGroups,
        pseudoGroups
      });
    }
  }, [disabled, pseudoGroups ? Object.keys([...pseudoGroups]).join("") : 0, mediaGroups ? Object.keys([...mediaGroups]).join("") : 0]), [splitStyles.viewProps, splitStyles.style || {}, theme, mediaState];
}

// node_modules/@tamagui/web/dist/esm/views/FontLanguage.mjs
var import_jsx_runtime8 = __toESM(require_jsx_runtime(), 1);
var FontLanguage = ({
  children,
  ...props
}) => (0, import_jsx_runtime8.jsx)("div", {
  style: {
    display: "contents"
  },
  className: Object.entries(props).map(([name, language]) => `t_lang-${name}-${language}`).join(" "),
  children
});
FontLanguage.displayName = "FontLanguage";

// node_modules/@tamagui/web/dist/esm/views/Configuration.mjs
var import_react18 = __toESM(require_react(), 1);
var import_jsx_runtime9 = __toESM(require_jsx_runtime(), 1);
var Configuration = (props) => {
  const current = import_react18.default.useContext(ComponentContext);
  return (0, import_jsx_runtime9.jsx)(ComponentContext.Provider, {
    ...current,
    ...props
  });
};
Configuration.displayName = "Configuration";

// node_modules/@tamagui/use-event/dist/esm/useGet.mjs
var React13 = __toESM(require_react(), 1);
function useGet(currentValue, initialValue, forwardToFunction) {
  const curRef = React13.useRef(initialValue ?? currentValue);
  return useIsomorphicLayoutEffect(() => {
    curRef.current = currentValue;
  }), React13.useCallback(forwardToFunction ? (...args) => {
    var _a2;
    return (_a2 = curRef.current) == null ? void 0 : _a2.apply(null, args);
  } : () => curRef.current, []);
}

// node_modules/@tamagui/use-event/dist/esm/useEvent.mjs
function useEvent(callback) {
  return useGet(callback, defaultValue, true);
}
var defaultValue = () => {
  throw new Error("Cannot call an event handler while rendering.");
};

// node_modules/@tamagui/web/dist/esm/Tamagui.mjs
var Tamagui = (() => {
  if (true) {
    class TamaguiManager {
      constructor() {
        __publicField(this, "Helpers", esm_exports);
      }
      get mediaState() {
        return {
          ...mediaState
        };
      }
      get config() {
        return getConfig();
      }
      get insertedRules() {
        return getAllRules();
      }
      get allSelectors() {
        return getAllSelectors();
      }
      get allTransforms() {
        return getAllTransforms();
      }
      get identifierToValue() {
        return identifierToValue;
      }
    }
    return new TamaguiManager();
  }
})();
var identifierToValue = /* @__PURE__ */ new Map();

// node_modules/@tamagui/web/dist/esm/helpers/getThemeCSSRules.mjs
var darkLight = ["dark", "light"];
var lightDark = ["light", "dark"];
function getThemeCSSRules(props) {
  const cssRuleSets = [];
  if (!process.env.TAMAGUI_DOES_SSR_CSS || process.env.TAMAGUI_DOES_SSR_CSS === "mutates-themes" || process.env.TAMAGUI_DOES_SSR_CSS === "false") {
    const {
      config,
      themeName,
      theme,
      names
    } = props, hasDarkLight = props.hasDarkLight ?? (config.themes && ("light" in config.themes || "dark" in config.themes)), CNP = `.${THEME_CLASSNAME_PREFIX}`;
    let vars = "";
    for (const themeKey in theme) {
      const variable = theme[themeKey];
      let value = null;
      tokensValueToVariable.has(variable.val) ? value = tokensValueToVariable.get(variable.val).variable : value = variable.val, vars += `--${process.env.TAMAGUI_CSS_VARIABLE_PREFIX || ""}${simpleHash(themeKey, 40)}:${value};`;
    }
    const isDarkBase = themeName === "dark", isLightBase = themeName === "light", baseSelectors = names.map((name) => `${CNP}${name}`), selectorsSet = new Set(isDarkBase || isLightBase ? baseSelectors : []);
    if (hasDarkLight) {
      const maxDepth = getSetting("maxDarkLightNesting") ?? 3;
      for (const subName of names) {
        const isDark = isDarkBase || subName.startsWith("dark_"), isLight = !isDark && (isLightBase || subName.startsWith("light_"));
        if (!(isDark || isLight)) {
          selectorsSet.add(`${CNP}${subName}`);
          continue;
        }
        const childSelector = `${CNP}${subName.replace(/^(dark|light)_/, "")}`, order = isDark ? darkLight : lightDark, [stronger, weaker] = order, numSelectors = Math.round(maxDepth * 1.5);
        for (let depth = 0; depth < numSelectors; depth++) {
          const isOdd = depth % 2 === 1;
          if (isOdd && depth < 3) continue;
          const parents = new Array(depth + 1).fill(0).map((_, idx) => `${CNP}${idx % 2 === 0 ? stronger : weaker}`);
          let parentSelectors = parents.length > 1 ? parents.slice(1) : parents;
          if (isOdd) {
            const [_first, second, ...rest] = parentSelectors;
            parentSelectors = [second, ...rest, second];
          }
          const lastParentSelector = parentSelectors[parentSelectors.length - 1], nextChildSelector = childSelector === lastParentSelector ? "" : childSelector, parentSelectorString = parentSelectors.join(" ");
          selectorsSet.add(`${parentSelectorString} ${nextChildSelector}`);
        }
      }
    }
    const selectors2 = [...selectorsSet].sort(sortString), css = `${selectors2.map((x) => `:root${isBaseTheme(x) && getSetting("themeClassNameOnRoot") ? "" : " "}${x}`).join(", ") + ", .tm_xxt"} {${vars}}`;
    if (cssRuleSets.push(css), getSetting("shouldAddPrefersColorThemes")) {
      const bgString = theme.background ? `background:${variableToString(theme.background)};` : "", fgString = theme.color ? `color:${variableToString(theme.color)}` : "", bodyRules = `body{${bgString}${fgString}}`, isDark = themeName.startsWith("dark"), baseName = isDark ? "dark" : "light", themeRules = `${selectors2.map((x) => {
        if (x == darkSelector || x === lightSelector) return ":root";
        if (!(isDark && x.startsWith(lightSelector) || !isDark && x.startsWith(darkSelector))) return x.replace(/^\.t_(dark|light) /, "").trim();
      }).filter(Boolean).join(", ")} {${vars}}`, prefersMediaSelectors = `@media(prefers-color-scheme:${baseName}){
    ${bodyRules}
    ${themeRules}
  }`;
      cssRuleSets.push(prefersMediaSelectors);
    }
    const selectionStyles = getSetting("selectionStyles");
    if (selectionStyles) {
      const rules = selectionStyles(theme);
      if (rules) {
        const selectionSelectors = baseSelectors.map((s) => `${s} ::selection`).join(", "), styles = Object.entries(rules).flatMap(([k, v]) => v ? `${k === "backgroundColor" ? "background" : k}:${variableToString(v)}` : []).join(";");
        if (styles) {
          const css2 = `${selectionSelectors}{${styles}}`;
          cssRuleSets.push(css2);
        }
      }
    }
  }
  return cssRuleSets;
}
var darkSelector = ".t_dark";
var lightSelector = ".t_light";
var isBaseTheme = (x) => x === darkSelector || x === lightSelector || x.startsWith(".t_dark ") || x.startsWith(".t_light ");

// node_modules/@tamagui/web/dist/esm/helpers/proxyThemeToParents.mjs
var themesRaw = {};
function proxyThemesToParents(dedupedThemes) {
  for (const {
    names,
    theme
  } of dedupedThemes) for (const name of names) themesRaw[name] = theme;
  const themes2 = {};
  for (const {
    names,
    theme
  } of dedupedThemes) for (const themeName of names) {
    const proxiedTheme = proxyThemeToParents(themeName, theme);
    themes2[themeName] = proxiedTheme;
  }
  return themes2;
}
function proxyThemeToParents(themeName, theme) {
  const out = {}, cur = [], parents = themeName.split("_").slice(0, -1).map((part) => (cur.push(part), cur.join("_")));
  for (const parent of parents) Object.assign(out, themesRaw[parent]);
  return Object.assign(out, theme), out;
}

// node_modules/@tamagui/web/dist/esm/helpers/themes.mjs
function ensureThemeVariable(theme, key) {
  const val = theme[key];
  isVariable(val) ? val.name !== key && (theme[key] = createVariable({
    key: val.name,
    name: key,
    val: val.val
  })) : theme[key] = createVariable({
    key,
    name: key,
    val
  });
}

// node_modules/@tamagui/web/dist/esm/createTamagui.mjs
var createdConfigs = /* @__PURE__ */ new WeakMap();
function createTamagui(configIn) {
  var _a2, _b;
  if (false) return console.warn("Warning: You somehow have duplicate Tamagui dependencies, this can cause issues. Tamagui is working around this by loading a previously loaded config in test mode. "), globalThis.__tamaguiConfig;
  if (createdConfigs.has(configIn)) return configIn;
  const tokensParsed = {}, tokens = createVariables(configIn.tokens || {});
  if (configIn.tokens) {
    const tokensMerged2 = {};
    for (const cat in tokens) {
      tokensParsed[cat] = {}, tokensMerged2[cat] = {};
      const tokenCat = tokens[cat];
      for (const key in tokenCat) {
        const val = tokenCat[key], prefixedKey = `$${key}`;
        tokensParsed[cat][prefixedKey] = val, tokensMerged2[cat][prefixedKey] = val, tokensMerged2[cat][key] = val;
      }
    }
    setTokens(tokensMerged2);
  }
  let foundThemes;
  if (configIn.themes) {
    const noThemes = Object.keys(configIn.themes).length === 0;
    noThemes && (foundThemes = scanAllSheets(noThemes, tokensParsed)), process.env.TAMAGUI_REACT_19 && process.env.TAMAGUI_SKIP_THEME_OPTIMIZATION || noThemes && listenForSheetChanges();
  }
  let fontSizeTokens = null, fontsParsed;
  if (configIn.fonts) {
    const fontTokens = Object.fromEntries(Object.entries(configIn.fonts).map(([k, v]) => [k, createVariables(v, "f", true)]));
    fontsParsed = (() => {
      const res = {};
      for (const familyName in fontTokens) {
        const font = fontTokens[familyName], fontParsed = parseFont(font);
        res[`$${familyName}`] = fontParsed, !fontSizeTokens && fontParsed.size && (fontSizeTokens = new Set(Object.keys(fontParsed.size)));
      }
      return res;
    })();
  }
  const specificTokens = {}, themeConfig = (() => {
    const cssRuleSets = [], declarations = [], fontDeclarations = {};
    for (const key in tokens) for (const skey in tokens[key]) {
      const variable = tokens[key][skey];
      if (specificTokens[`$${key}.${skey}`] = variable, typeof variable > "u") throw new Error(`No value for tokens.${key}.${skey}:
${JSON.stringify(variable, null, 2)}`);
      isWeb && (registerCSSVariable(variable), declarations.push(variableToCSS(variable, key === "zIndex")));
    }
    {
      let declarationsToRuleSet = function(decs, selector = "") {
        return `:root${selector} {${sep}${[...decs].join(`;${sep}`)}${sep}}`;
      };
      for (const key in fontsParsed) {
        const fontParsed = fontsParsed[key], [name, language] = key.includes("_") ? key.split("_") : [key], fontVars = registerFontVariables(fontParsed);
        fontDeclarations[key] = {
          name: name.slice(1),
          declarations: fontVars,
          language
        };
      }
      const sep = configIn.cssStyleSeparator || "";
      if (cssRuleSets.push(declarationsToRuleSet(declarations)), fontDeclarations) for (const key in fontDeclarations) {
        const {
          name,
          declarations: declarations2,
          language = "default"
        } = fontDeclarations[key], fontSelector = `.font_${name}`, langSelector = `:root .t_lang-${name}-${language} ${fontSelector}`, selectors2 = language === "default" ? ` ${fontSelector}, ${langSelector}` : langSelector, specificRuleSet = declarationsToRuleSet(declarations2, selectors2);
        cssRuleSets.push(specificRuleSet);
      }
    }
    const themesIn = configIn.themes, dedupedThemes = foundThemes ?? getThemesDeduped(themesIn);
    return {
      themes: proxyThemesToParents(dedupedThemes),
      cssRuleSets,
      getThemeRulesSets() {
        let themeRuleSets = [];
        if (isWeb) for (const {
          names,
          theme
        } of dedupedThemes) {
          const nextRules = getThemeCSSRules({
            config: configIn,
            themeName: names[0],
            names,
            theme
          });
          themeRuleSets = [...themeRuleSets, ...nextRules];
        }
        return themeRuleSets;
      }
    };
  })(), shorthands = configIn.shorthands || {};
  let lastCSSInsertedRulesIndex = -1;
  const getCSS = (opts = {}) => {
    {
      const {
        separator = `
`,
        sinceLastCall,
        exclude
      } = opts;
      if (sinceLastCall && lastCSSInsertedRulesIndex >= 0) {
        const rules = getAllRules();
        return lastCSSInsertedRulesIndex = rules.length, rules.slice(lastCSSInsertedRulesIndex).join(separator);
      }
      lastCSSInsertedRulesIndex = 0;
      const runtimeStyles = getAllRules().join(separator);
      return exclude === "design-system" ? runtimeStyles : `${`._ovs-contain {overscroll-behavior:contain;}
  .is_Text .is_Text {display:inline-flex;}
  ._dsp_contents {display:contents;}
  ${themeConfig.cssRuleSets.join(separator)}`}
  ${exclude ? "" : themeConfig.getThemeRulesSets().join(separator)}
  ${runtimeStyles}`;
    }
  }, getNewCSS = (opts) => getCSS({
    ...opts,
    sinceLastCall: true
  }), defaultFontSetting = ((_a2 = configIn.settings) == null ? void 0 : _a2.defaultFont) ?? configIn.defaultFont, defaultFont = (() => {
    let val = defaultFontSetting;
    return (val == null ? void 0 : val[0]) === "$" && (val = val.slice(1)), val;
  })(), defaultFontToken = defaultFont ? `$${defaultFont}` : "", unset = {
    ...configIn.unset
  };
  !unset.fontFamily && defaultFont && (unset.fontFamily = defaultFontToken);
  const config = {
    fonts: {},
    onlyAllowShorthands: false,
    fontLanguages: [],
    animations: {},
    media: {},
    ...configIn,
    unset,
    settings: {
      // move deprecated settings here so we can reference them all using `getSetting`
      // TODO remove this on v2
      disableSSR: configIn.disableSSR,
      defaultFont: configIn.defaultFont,
      disableRootThemeClass: configIn.disableRootThemeClass,
      onlyAllowShorthands: configIn.onlyAllowShorthands,
      mediaQueryDefaultActive: configIn.mediaQueryDefaultActive,
      themeClassNameOnRoot: configIn.themeClassNameOnRoot,
      cssStyleSeparator: configIn.cssStyleSeparator,
      webContainerType: "inline-size",
      ...configIn.settings
    },
    tokens,
    // vite made this into a function if it wasn't set
    shorthands,
    inverseShorthands: shorthands ? Object.fromEntries(Object.entries(shorthands).map(([k, v]) => [v, k])) : {},
    themes: themeConfig.themes,
    fontsParsed: fontsParsed || {},
    themeConfig,
    tokensParsed,
    parsed: true,
    getNewCSS,
    getCSS,
    defaultFont,
    fontSizeTokens: fontSizeTokens || /* @__PURE__ */ new Set(),
    specificTokens,
    defaultFontToken
    // const tokens = [...getToken(tokens.size[0])]
    // .spacer-sm + ._dsp_contents._dsp-sm-hidden { margin-left: -var(--${}) }
  };
  return setConfig(config), configureMedia(config), createdConfigs.set(config, true), false, configListeners.size && (configListeners.forEach((cb) => cb(config)), configListeners.clear()), ((_b = process.env.DEBUG) == null ? void 0 : _b.startsWith("tamagui")) && console.info("Tamagui config:", config), globalThis.Tamagui || (globalThis.Tamagui = Tamagui), config;
}
function getThemesDeduped(themes2) {
  const dedupedThemes = [], existing = /* @__PURE__ */ new Map();
  for (const themeName in themes2) {
    const darkOrLightSpecificPrefix = themeName.startsWith("dark") ? "dark" : themeName.startsWith("light") ? "light" : "", rawTheme = themes2[themeName], key = darkOrLightSpecificPrefix + JSON.stringify(rawTheme);
    if (existing.has(key)) {
      existing.get(key).names.push(themeName);
      continue;
    }
    const theme = {
      ...rawTheme
    };
    for (const key2 in theme) ensureThemeVariable(theme, key2);
    const deduped = {
      names: [themeName],
      theme
    };
    dedupedThemes.push(deduped), existing.set(key, deduped);
  }
  return dedupedThemes;
}

// node_modules/@tamagui/web/dist/esm/_withStableStyle.mjs
var import_react19 = __toESM(require_react(), 1);
var import_jsx_runtime10 = __toESM(require_jsx_runtime(), 1);

// node_modules/@tamagui/web/dist/esm/views/View.mjs
var View = createComponent({
  acceptsClassName: true,
  defaultProps: stackDefaultStyles,
  validStyles
});

// node_modules/@tamagui/web/dist/esm/views/Text.mjs
var ellipseStyle = {
  maxWidth: "100%",
  overflow: "hidden",
  textOverflow: "ellipsis",
  whiteSpace: "nowrap"
};
var defaultWebStyle = {
  display: "inline",
  // display: inline breaks css transform styles
  boxSizing: "border-box",
  wordWrap: "break-word",
  whiteSpace: "pre-wrap",
  margin: 0
};
var ellipsisStyle = ellipseStyle;
var Text = createComponent({
  acceptsClassName: true,
  isText: true,
  defaultProps: {
    fontFamily: "unset",
    ...defaultWebStyle
  },
  inlineWhenUnflattened: /* @__PURE__ */ new Set(["fontFamily"]),
  variants: {
    numberOfLines: {
      1: ellipseStyle,
      ":number": (numberOfLines) => numberOfLines >= 1 ? {
        WebkitLineClamp: numberOfLines,
        WebkitBoxOrient: "vertical",
        display: "-webkit-box",
        overflow: "hidden"
      } : null
    },
    selectable: {
      true: {
        userSelect: "text",
        cursor: "text"
      },
      false: {
        userSelect: "none",
        cursor: "default"
      }
    },
    /**
     * @deprecated Use ellipsis instead
     */
    ellipse: {
      true: ellipsisStyle
    },
    ellipsis: {
      true: ellipsisStyle
    }
  },
  validStyles: {
    ...validStyles,
    ...stylePropsTextOnly
  }
});
Text.displayName = "Text";

// node_modules/@tamagui/web/dist/esm/views/ThemeProvider.mjs
var import_react20 = __toESM(require_react(), 1);
var import_jsx_runtime11 = __toESM(require_jsx_runtime(), 1);
var ThemeProvider = (props) => {
  const disableRootThemeClass = props.disableRootThemeClass ?? getSetting("disableRootThemeClass"), themeClassNameOnRoot = props.themeClassNameOnRoot ?? getSetting("themeClassNameOnRoot");
  return isClient && useIsomorphicLayoutEffect(() => {
    if (disableRootThemeClass) return;
    const cn = `${THEME_CLASSNAME_PREFIX}${props.defaultTheme}`, target = themeClassNameOnRoot ? document.documentElement : document.body;
    return target.classList.add(cn), () => {
      target.classList.remove(cn);
    };
  }, [props.defaultTheme, disableRootThemeClass, themeClassNameOnRoot]), (0, import_jsx_runtime11.jsx)(Theme, {
    className: props.className,
    name: props.defaultTheme,
    forceClassName: !disableRootThemeClass && !themeClassNameOnRoot,
    _isRoot: import_react20.useId,
    children: props.children
  });
};

// node_modules/@tamagui/web/dist/esm/views/TamaguiProvider.mjs
var import_react21 = __toESM(require_react(), 1);
var import_jsx_runtime12 = __toESM(require_jsx_runtime(), 1);
function TamaguiProvider({
  children,
  disableInjectCSS,
  config,
  className,
  defaultTheme,
  disableRootThemeClass,
  reset,
  themeClassNameOnRoot
}) {
  return process.env.TAMAGUI_REACT_19 || isClient && useIsomorphicLayoutEffect(() => {
    if (config && !disableInjectCSS) {
      const style = document.createElement("style");
      return style.appendChild(document.createTextNode(config.getCSS())), document.head.appendChild(style), () => {
        document.head.removeChild(style);
      };
    }
  }, [config, disableInjectCSS]), useIsomorphicLayoutEffect(() => {
    updateMediaListeners();
  }, []), (0, import_jsx_runtime12.jsxs)(import_jsx_runtime12.Fragment, {
    children: [(0, import_jsx_runtime12.jsx)(UnmountedClassName, {
      children: (0, import_jsx_runtime12.jsx)(ComponentContext.Provider, {
        animationDriver: config == null ? void 0 : config.animations,
        children: (0, import_jsx_runtime12.jsx)(ThemeProvider, {
          themeClassNameOnRoot: themeClassNameOnRoot ?? getSetting("themeClassNameOnRoot"),
          disableRootThemeClass: disableRootThemeClass ?? getSetting("disableRootThemeClass"),
          defaultTheme: defaultTheme ?? (config ? Object.keys(config.themes)[0] : ""),
          reset,
          className,
          children
        })
      })
    }), process.env.TAMAGUI_REACT_19 && config && !disableInjectCSS && (0, import_jsx_runtime12.jsx)("style", {
      precedence: "default",
      href: "tamagui-css",
      children: config.getCSS()
    }, "tamagui-css")]
  });
}
function UnmountedClassName(props) {
  const [mounted, setMounted] = import_react21.default.useState(false);
  return import_react21.default.useEffect(() => {
    setMounted(true);
  }, []), isWeb ? (0, import_jsx_runtime12.jsx)("span", {
    style: {
      display: "contents"
    },
    className: mounted ? "" : "t_unmounted",
    children: props.children
  }) : props.children;
}
TamaguiProvider.displayName = "TamaguiProvider";

// node_modules/@tamagui/react-native-media-driver/dist/esm/matchMedia.mjs
var matchMedia2 = globalThis.matchMedia;

// node_modules/@tamagui/react-native-media-driver/dist/esm/createMedia.mjs
function createMedia(media) {
  return setupMatchMedia(matchMedia2), media;
}

// node_modules/@tamagui/react-native-use-responder-events/dist/esm/useResponderEvents.mjs
var React16 = __toESM(require_react(), 1);

// node_modules/@tamagui/react-native-use-responder-events/dist/esm/utils.mjs
var keyName = "__reactResponderId";
var canUseDOM = !!(typeof window < "u" && window.document && window.document.createElement);
var getBoundingClientRect = (node2) => {
  if (node2 && node2.nodeType === 1 && node2.getBoundingClientRect) return node2.getBoundingClientRect();
};
function getEventPath(domEvent) {
  var _a2;
  if (domEvent.type === "selectionchange") {
    const target = (_a2 = window.getSelection()) == null ? void 0 : _a2.anchorNode;
    return composedPathFallback(target);
  }
  return domEvent.composedPath != null ? domEvent.composedPath() : composedPathFallback(domEvent.target);
}
function composedPathFallback(target) {
  const path = [];
  for (; target != null && target !== document.body; ) path.push(target), target = target.parentNode;
  return path;
}
function getResponderId(node2) {
  return node2 != null ? node2[keyName] : null;
}
function setResponderId(node2, id) {
  node2 != null && (node2[keyName] = id);
}
function getResponderPaths(domEvent) {
  const idPath = [], nodePath = [], eventPath = getEventPath(domEvent);
  for (let i = 0; i < eventPath.length; i++) {
    const node2 = eventPath[i], id = getResponderId(node2);
    id != null && (idPath.push(id), nodePath.push(node2));
  }
  return {
    idPath,
    nodePath
  };
}
function getLowestCommonAncestor(pathA, pathB) {
  let pathALength = pathA.length, pathBLength = pathB.length;
  if (
    // If either path is empty
    pathALength === 0 || pathBLength === 0 || // If the last elements aren't the same there can't be a common ancestor
    // that is connected to the responder system
    pathA[pathALength - 1] !== pathB[pathBLength - 1]
  ) return null;
  let itemA = pathA[0], indexA = 0, itemB = pathB[0], indexB = 0;
  pathALength - pathBLength > 0 && (indexA = pathALength - pathBLength, itemA = pathA[indexA], pathALength = pathBLength), pathBLength - pathALength > 0 && (indexB = pathBLength - pathALength, itemB = pathB[indexB], pathBLength = pathALength);
  let depth = pathALength;
  for (; depth--; ) {
    if (itemA === itemB) return itemA;
    itemA = pathA[indexA++], itemB = pathB[indexB++];
  }
  return null;
}
function hasTargetTouches(target, touches) {
  if (!touches || touches.length === 0) return false;
  for (let i = 0; i < touches.length; i++) {
    const node2 = touches[i].target;
    if (node2 != null && target.contains(node2)) return true;
  }
  return false;
}
function hasValidSelection(domEvent) {
  return domEvent.type === "selectionchange" ? isSelectionValid() : domEvent.type === "select";
}
function isPrimaryPointerDown(domEvent) {
  const {
    altKey,
    button,
    buttons,
    ctrlKey,
    type
  } = domEvent, isTouch = type === "touchstart" || type === "touchmove", isPrimaryMouseDown = type === "mousedown" && (button === 0 || buttons === 1), isPrimaryMouseMove = type === "mousemove" && buttons === 1, noModifiers = altKey === false && ctrlKey === false;
  return !!(isTouch || isPrimaryMouseDown && noModifiers || isPrimaryMouseMove && noModifiers);
}
function isSelectionValid() {
  const selection = window.getSelection();
  if (!selection) return false;
  const string = selection.toString(), anchorNode = selection.anchorNode, focusNode = selection.focusNode, isTextNode = anchorNode && anchorNode.nodeType === window.Node.TEXT_NODE || focusNode && focusNode.nodeType === window.Node.TEXT_NODE;
  return string.length >= 1 && string !== `
` && !!isTextNode;
}

// node_modules/@tamagui/react-native-use-responder-events/dist/esm/createResponderEvent.mjs
var emptyFunction = () => {
};
var emptyObject2 = {};
var emptyArray = [];
function normalizeIdentifier(identifier) {
  return identifier > 20 ? identifier % 20 : identifier;
}
function createResponderEvent(domEvent, responderTouchHistoryStore2) {
  let rect, propagationWasStopped = false, changedTouches, touches;
  const domEventChangedTouches = domEvent.changedTouches, domEventType = domEvent.type, metaKey = domEvent.metaKey === true, shiftKey = domEvent.shiftKey === true, force = (domEventChangedTouches == null ? void 0 : domEventChangedTouches[0].force) || 0, identifier = normalizeIdentifier((domEventChangedTouches == null ? void 0 : domEventChangedTouches[0].identifier) || 0), clientX = (domEventChangedTouches == null ? void 0 : domEventChangedTouches[0].clientX) || domEvent.clientX, clientY = (domEventChangedTouches == null ? void 0 : domEventChangedTouches[0].clientY) || domEvent.clientY, pageX = (domEventChangedTouches == null ? void 0 : domEventChangedTouches[0].pageX) || domEvent.pageX, pageY = (domEventChangedTouches == null ? void 0 : domEventChangedTouches[0].pageY) || domEvent.pageY, preventDefault = typeof domEvent.preventDefault == "function" ? domEvent.preventDefault.bind(domEvent) : emptyFunction, timestamp = domEvent.timeStamp;
  function normalizeTouches(touches2) {
    return Array.prototype.slice.call(touches2).map((touch) => ({
      force: touch.force,
      identifier: normalizeIdentifier(touch.identifier),
      get locationX() {
        return locationX(touch.clientX);
      },
      get locationY() {
        return locationY(touch.clientY);
      },
      pageX: touch.pageX,
      pageY: touch.pageY,
      target: touch.target,
      timestamp
    }));
  }
  if (domEventChangedTouches != null) changedTouches = normalizeTouches(domEventChangedTouches), touches = normalizeTouches(domEvent.touches);
  else {
    const emulatedTouches = [{
      force,
      identifier,
      get locationX() {
        return locationX(clientX);
      },
      get locationY() {
        return locationY(clientY);
      },
      pageX,
      pageY,
      target: domEvent.target,
      timestamp
    }];
    changedTouches = emulatedTouches, touches = domEventType === "mouseup" || domEventType === "dragstart" ? emptyArray : emulatedTouches;
  }
  const responderEvent = {
    bubbles: true,
    cancelable: true,
    // `currentTarget` is set before dispatch
    currentTarget: null,
    defaultPrevented: domEvent.defaultPrevented,
    dispatchConfig: emptyObject2,
    eventPhase: domEvent.eventPhase,
    isDefaultPrevented() {
      return domEvent.defaultPrevented;
    },
    isPropagationStopped() {
      return propagationWasStopped;
    },
    isTrusted: domEvent.isTrusted,
    nativeEvent: {
      altKey: false,
      ctrlKey: false,
      metaKey,
      shiftKey,
      changedTouches,
      force,
      identifier,
      get locationX() {
        return locationX(clientX);
      },
      get locationY() {
        return locationY(clientY);
      },
      pageX,
      pageY,
      target: domEvent.target,
      timestamp,
      touches,
      type: domEventType
    },
    persist: emptyFunction,
    preventDefault,
    stopPropagation() {
      propagationWasStopped = true;
    },
    target: domEvent.target,
    timeStamp: timestamp,
    touchHistory: responderTouchHistoryStore2.touchHistory
  };
  function locationX(x) {
    if (rect = rect || getBoundingClientRect(responderEvent.currentTarget), rect) return x - rect.left;
  }
  function locationY(y) {
    if (rect = rect || getBoundingClientRect(responderEvent.currentTarget), rect) return y - rect.top;
  }
  return responderEvent;
}

// node_modules/@tamagui/react-native-use-responder-events/dist/esm/types.mjs
var MOUSE_DOWN = "mousedown";
var MOUSE_MOVE = "mousemove";
var MOUSE_UP = "mouseup";
var MOUSE_CANCEL = "dragstart";
var TOUCH_START = "touchstart";
var TOUCH_MOVE = "touchmove";
var TOUCH_END = "touchend";
var TOUCH_CANCEL = "touchcancel";
var SCROLL = "scroll";
var SELECT = "select";
var SELECTION_CHANGE = "selectionchange";
function isStartish(eventType) {
  return eventType === TOUCH_START || eventType === MOUSE_DOWN;
}
function isMoveish(eventType) {
  return eventType === TOUCH_MOVE || eventType === MOUSE_MOVE;
}
function isEndish(eventType) {
  return eventType === TOUCH_END || eventType === MOUSE_UP || isCancelish(eventType);
}
function isCancelish(eventType) {
  return eventType === TOUCH_CANCEL || eventType === MOUSE_CANCEL;
}
function isScroll(eventType) {
  return eventType === SCROLL;
}
function isSelectionChange(eventType) {
  return eventType === SELECT || eventType === SELECTION_CHANGE;
}

// node_modules/@tamagui/react-native-use-responder-events/dist/esm/ResponderTouchHistoryStore.mjs
var ResponderTouchHistoryStore = class {
  constructor() {
    __publicField(this, "_touchHistory", {
      touchBank: [],
      //Array<TouchRecord>
      numberActiveTouches: 0,
      // If there is only one active touch, we remember its location. This prevents
      // us having to loop through all of the touches all the time in the most
      // common case.
      indexOfSingleActiveTouch: -1,
      mostRecentTimeStamp: 0
    });
  }
  recordTouchTrack(topLevelType, nativeEvent) {
    var _a2, _b;
    const touchHistory = this._touchHistory;
    if (isMoveish(topLevelType)) nativeEvent.changedTouches.forEach((touch) => recordTouchMove(touch, touchHistory));
    else if (isStartish(topLevelType)) nativeEvent.changedTouches.forEach((touch) => recordTouchStart(touch, touchHistory)), touchHistory.numberActiveTouches = nativeEvent.touches.length, touchHistory.numberActiveTouches === 1 && (touchHistory.indexOfSingleActiveTouch = nativeEvent.touches[0].identifier);
    else if (isEndish(topLevelType) && (nativeEvent.changedTouches.forEach((touch) => recordTouchEnd(touch, touchHistory)), touchHistory.numberActiveTouches = nativeEvent.touches.length, touchHistory.numberActiveTouches === 1)) {
      const {
        touchBank
      } = touchHistory;
      for (let i = 0; i < touchBank.length; i++) if ((_a2 = touchBank[i]) == null ? void 0 : _a2.touchActive) {
        touchHistory.indexOfSingleActiveTouch = i;
        break;
      }
      ((_b = touchBank[touchHistory.indexOfSingleActiveTouch]) == null ? void 0 : _b.touchActive) || console.error("Cannot find single active touch.");
    }
  }
  get touchHistory() {
    return this._touchHistory;
  }
};
var MAX_TOUCH_BANK = 20;
function timestampForTouch(touch) {
  return touch.timeStamp || touch.timestamp;
}
function createTouchRecord(touch) {
  return {
    touchActive: true,
    startPageX: touch.pageX,
    startPageY: touch.pageY,
    startTimeStamp: timestampForTouch(touch),
    currentPageX: touch.pageX,
    currentPageY: touch.pageY,
    currentTimeStamp: timestampForTouch(touch),
    previousPageX: touch.pageX,
    previousPageY: touch.pageY,
    previousTimeStamp: timestampForTouch(touch)
  };
}
function resetTouchRecord(touchRecord, touch) {
  touchRecord.touchActive = true, touchRecord.startPageX = touch.pageX, touchRecord.startPageY = touch.pageY, touchRecord.startTimeStamp = timestampForTouch(touch), touchRecord.currentPageX = touch.pageX, touchRecord.currentPageY = touch.pageY, touchRecord.currentTimeStamp = timestampForTouch(touch), touchRecord.previousPageX = touch.pageX, touchRecord.previousPageY = touch.pageY, touchRecord.previousTimeStamp = timestampForTouch(touch);
}
function getTouchIdentifier({
  identifier
}) {
  return identifier == null && console.error("Touch object is missing identifier."), identifier > MAX_TOUCH_BANK && console.error("Touch identifier %s is greater than maximum supported %s which causes performance issues backfilling array locations for all of the indices.", identifier, MAX_TOUCH_BANK), identifier;
}
function recordTouchStart(touch, touchHistory) {
  const identifier = getTouchIdentifier(touch), touchRecord = touchHistory.touchBank[identifier];
  touchRecord ? resetTouchRecord(touchRecord, touch) : touchHistory.touchBank[identifier] = createTouchRecord(touch), touchHistory.mostRecentTimeStamp = timestampForTouch(touch);
}
function recordTouchMove(touch, touchHistory) {
  const touchRecord = touchHistory.touchBank[getTouchIdentifier(touch)];
  touchRecord ? (touchRecord.touchActive = true, touchRecord.previousPageX = touchRecord.currentPageX, touchRecord.previousPageY = touchRecord.currentPageY, touchRecord.previousTimeStamp = touchRecord.currentTimeStamp, touchRecord.currentPageX = touch.pageX, touchRecord.currentPageY = touch.pageY, touchRecord.currentTimeStamp = timestampForTouch(touch), touchHistory.mostRecentTimeStamp = timestampForTouch(touch)) : console.warn(`Cannot record touch move without a touch start.
`, `Touch Move: ${printTouch(touch)}
`, `Touch Bank: ${printTouchBank(touchHistory)}`);
}
function recordTouchEnd(touch, touchHistory) {
  const touchRecord = touchHistory.touchBank[getTouchIdentifier(touch)];
  touchRecord ? (touchRecord.touchActive = false, touchRecord.previousPageX = touchRecord.currentPageX, touchRecord.previousPageY = touchRecord.currentPageY, touchRecord.previousTimeStamp = touchRecord.currentTimeStamp, touchRecord.currentPageX = touch.pageX, touchRecord.currentPageY = touch.pageY, touchRecord.currentTimeStamp = timestampForTouch(touch), touchHistory.mostRecentTimeStamp = timestampForTouch(touch)) : console.warn(`Cannot record touch end without a touch start.
`, `Touch End: ${printTouch(touch)}
`, `Touch Bank: ${printTouchBank(touchHistory)}`);
}
function printTouch(touch) {
  return JSON.stringify({
    identifier: touch.identifier,
    pageX: touch.pageX,
    pageY: touch.pageY,
    timestamp: timestampForTouch(touch)
  });
}
function printTouchBank(touchHistory) {
  const {
    touchBank
  } = touchHistory;
  let printed = JSON.stringify(touchBank.slice(0, MAX_TOUCH_BANK));
  return touchBank.length > MAX_TOUCH_BANK && (printed += ` (original size: ${touchBank.length})`), printed;
}

// node_modules/@tamagui/react-native-use-responder-events/dist/esm/ResponderSystem.mjs
var emptyObject3 = {};
var startRegistration = ["onStartShouldSetResponderCapture", "onStartShouldSetResponder", {
  bubbles: true
}];
var moveRegistration = ["onMoveShouldSetResponderCapture", "onMoveShouldSetResponder", {
  bubbles: true
}];
var scrollRegistration = ["onScrollShouldSetResponderCapture", "onScrollShouldSetResponder", {
  bubbles: false
}];
var shouldSetResponderEvents = {
  touchstart: startRegistration,
  mousedown: startRegistration,
  touchmove: moveRegistration,
  mousemove: moveRegistration,
  scroll: scrollRegistration
};
var emptyResponder = {
  id: null,
  idPath: null,
  node: null
};
var responderListenersMap = /* @__PURE__ */ new Map();
var isEmulatingMouseEvents = false;
var trackedTouchCount = 0;
var currentResponder = {
  id: null,
  node: null,
  idPath: null
};
var responderTouchHistoryStore = new ResponderTouchHistoryStore();
function changeCurrentResponder(responder) {
  currentResponder = responder;
}
function getResponderConfig(id) {
  const config = responderListenersMap.get(id);
  return config ?? emptyObject3;
}
function eventListener(domEvent) {
  const eventType = domEvent.type, eventTarget = domEvent.target;
  if (eventType === "touchstart" && (isEmulatingMouseEvents = true), (eventType === "touchmove" || trackedTouchCount > 1) && (isEmulatingMouseEvents = false), // Ignore browser emulated mouse events
  eventType === "mousedown" && isEmulatingMouseEvents || eventType === "mousemove" && isEmulatingMouseEvents || // Ignore mousemove if a mousedown didn't occur first
  eventType === "mousemove" && trackedTouchCount < 1) return;
  if (isEmulatingMouseEvents && eventType === "mouseup") {
    trackedTouchCount === 0 && (isEmulatingMouseEvents = false);
    return;
  }
  const isStartEvent = isStartish(eventType) && isPrimaryPointerDown(domEvent), isMoveEvent = isMoveish(eventType), isEndEvent = isEndish(eventType), isScrollEvent = isScroll(eventType), isSelectionChangeEvent = isSelectionChange(eventType), responderEvent = createResponderEvent(domEvent, responderTouchHistoryStore);
  (isStartEvent || isMoveEvent || isEndEvent) && (domEvent.touches ? trackedTouchCount = domEvent.touches.length : isStartEvent ? trackedTouchCount = 1 : isEndEvent && (trackedTouchCount = 0), responderTouchHistoryStore.recordTouchTrack(eventType, responderEvent.nativeEvent));
  let eventPaths = getResponderPaths(domEvent), wasNegotiated = false, wantsResponder;
  if (isStartEvent || isMoveEvent || isScrollEvent && trackedTouchCount > 0) {
    const currentResponderIdPath = currentResponder.idPath, eventIdPath = eventPaths.idPath;
    if (currentResponderIdPath != null && eventIdPath != null) {
      const lowestCommonAncestor = getLowestCommonAncestor(currentResponderIdPath, eventIdPath);
      if (lowestCommonAncestor != null) {
        const index = eventIdPath.indexOf(lowestCommonAncestor) + (lowestCommonAncestor === currentResponder.id ? 1 : 0);
        eventPaths = {
          idPath: eventIdPath.slice(index),
          nodePath: eventPaths.nodePath.slice(index)
        };
      } else eventPaths = null;
    }
    eventPaths != null && (wantsResponder = findWantsResponder(eventPaths, domEvent, responderEvent), wantsResponder != null && (attemptTransfer(responderEvent, wantsResponder), wasNegotiated = true));
  }
  if (currentResponder.id != null && currentResponder.node != null) {
    const {
      id,
      node: node2
    } = currentResponder, {
      onResponderStart,
      onResponderMove,
      onResponderEnd,
      onResponderRelease,
      onResponderTerminate,
      onResponderTerminationRequest
    } = getResponderConfig(id);
    if (responderEvent.bubbles = false, responderEvent.cancelable = false, responderEvent.currentTarget = node2, isStartEvent) onResponderStart != null && (responderEvent.dispatchConfig.registrationName = "onResponderStart", onResponderStart(responderEvent));
    else if (isMoveEvent) onResponderMove != null && (responderEvent.dispatchConfig.registrationName = "onResponderMove", onResponderMove(responderEvent));
    else {
      const isTerminateEvent = isCancelish(eventType) || // native context menu
      eventType === "contextmenu" || // window blur
      eventType === "blur" && eventTarget === window || // responder (or ancestors) blur
      eventType === "blur" && eventTarget.contains(node2) && domEvent.relatedTarget !== node2 || // native scroll without using a pointer
      isScrollEvent && trackedTouchCount === 0 || // native scroll on node that is parent of the responder (allow siblings to scroll)
      isScrollEvent && eventTarget.contains(node2) && eventTarget !== node2 || // native select/selectionchange on node
      isSelectionChangeEvent && hasValidSelection(domEvent), isReleaseEvent = isEndEvent && !isTerminateEvent && !hasTargetTouches(node2, domEvent.touches);
      if (isEndEvent && onResponderEnd != null && (responderEvent.dispatchConfig.registrationName = "onResponderEnd", onResponderEnd(responderEvent)), isReleaseEvent && (onResponderRelease != null && (responderEvent.dispatchConfig.registrationName = "onResponderRelease", onResponderRelease(responderEvent)), changeCurrentResponder(emptyResponder)), isTerminateEvent) {
        let shouldTerminate = true;
        (eventType === "contextmenu" || eventType === "scroll" || eventType === "selectionchange") && (wasNegotiated ? shouldTerminate = false : onResponderTerminationRequest != null && (responderEvent.dispatchConfig.registrationName = "onResponderTerminationRequest", onResponderTerminationRequest(responderEvent) === false && (shouldTerminate = false))), shouldTerminate && (onResponderTerminate != null && (responderEvent.dispatchConfig.registrationName = "onResponderTerminate", onResponderTerminate(responderEvent)), changeCurrentResponder(emptyResponder), isEmulatingMouseEvents = false, trackedTouchCount = 0);
      }
    }
  }
}
function findWantsResponder(eventPaths, domEvent, responderEvent) {
  const shouldSetCallbacks = shouldSetResponderEvents[domEvent.type];
  if (shouldSetCallbacks != null) {
    const {
      idPath,
      nodePath
    } = eventPaths, shouldSetCallbackCaptureName = shouldSetCallbacks[0], shouldSetCallbackBubbleName = shouldSetCallbacks[1], {
      bubbles
    } = shouldSetCallbacks[2], check = (id, node2, callbackName) => {
      const shouldSetCallback = getResponderConfig(id)[callbackName];
      if (shouldSetCallback != null && (responderEvent.currentTarget = node2, shouldSetCallback(responderEvent) === true)) {
        const prunedIdPath = idPath.slice(idPath.indexOf(id));
        return {
          id,
          node: node2,
          idPath: prunedIdPath
        };
      }
    };
    for (let i = idPath.length - 1; i >= 0; i--) {
      const id = idPath[i], node2 = nodePath[i], result = check(id, node2, shouldSetCallbackCaptureName);
      if (result != null) return result;
      if (responderEvent.isPropagationStopped() === true) return;
    }
    if (bubbles) for (let i = 0; i < idPath.length; i++) {
      const id = idPath[i], node2 = nodePath[i], result = check(id, node2, shouldSetCallbackBubbleName);
      if (result != null) return result;
      if (responderEvent.isPropagationStopped() === true) return;
    }
    else {
      const id = idPath[0], node2 = nodePath[0];
      if (domEvent.target === node2) return check(id, node2, shouldSetCallbackBubbleName);
    }
  }
}
function attemptTransfer(responderEvent, wantsResponder) {
  const {
    id: currentId,
    node: currentNode
  } = currentResponder, {
    id,
    node: node2
  } = wantsResponder, {
    onResponderGrant,
    onResponderReject
  } = getResponderConfig(id);
  if (responderEvent.bubbles = false, responderEvent.cancelable = false, responderEvent.currentTarget = node2, currentId == null) onResponderGrant != null && (responderEvent.currentTarget = node2, responderEvent.dispatchConfig.registrationName = "onResponderGrant", onResponderGrant(responderEvent)), changeCurrentResponder(wantsResponder);
  else {
    const {
      onResponderTerminate,
      onResponderTerminationRequest
    } = getResponderConfig(currentId);
    let allowTransfer = true;
    onResponderTerminationRequest != null && (responderEvent.currentTarget = currentNode, responderEvent.dispatchConfig.registrationName = "onResponderTerminationRequest", onResponderTerminationRequest(responderEvent) === false && (allowTransfer = false)), allowTransfer ? (onResponderTerminate != null && (responderEvent.currentTarget = currentNode, responderEvent.dispatchConfig.registrationName = "onResponderTerminate", onResponderTerminate(responderEvent)), onResponderGrant != null && (responderEvent.currentTarget = node2, responderEvent.dispatchConfig.registrationName = "onResponderGrant", onResponderGrant(responderEvent)), changeCurrentResponder(wantsResponder)) : onResponderReject != null && (responderEvent.currentTarget = node2, responderEvent.dispatchConfig.registrationName = "onResponderReject", onResponderReject(responderEvent));
  }
}
var documentEventsCapturePhase = ["blur", "scroll"];
var documentEventsBubblePhase = [
  // mouse
  "mousedown",
  "mousemove",
  "mouseup",
  "dragstart",
  // touch
  "touchstart",
  "touchmove",
  "touchend",
  "touchcancel",
  // other
  "contextmenu",
  "select",
  "selectionchange"
];
var isTamaguiResponderActive = Symbol();
function attachListeners() {
  canUseDOM && !window[isTamaguiResponderActive] && (window.addEventListener("blur", eventListener), documentEventsBubblePhase.forEach((eventType) => {
    document.addEventListener(eventType, eventListener);
  }), documentEventsCapturePhase.forEach((eventType) => {
    document.addEventListener(eventType, eventListener, true);
  }), window[isTamaguiResponderActive] = true);
}
function addNode(id, node2, config) {
  setResponderId(node2, id), responderListenersMap.set(id, config);
}
function removeNode(id) {
  currentResponder.id === id && terminateResponder(), responderListenersMap.has(id) && responderListenersMap.delete(id);
}
function terminateResponder() {
  const {
    id,
    node: node2
  } = currentResponder;
  if (id != null && node2 != null) {
    const {
      onResponderTerminate
    } = getResponderConfig(id);
    if (onResponderTerminate != null) {
      const event = createResponderEvent({}, responderTouchHistoryStore);
      event.currentTarget = node2, onResponderTerminate(event);
    }
    changeCurrentResponder(emptyResponder);
  }
  isEmulatingMouseEvents = false, trackedTouchCount = 0;
}
function getResponderNode() {
  return currentResponder.node;
}

// node_modules/@tamagui/react-native-use-responder-events/dist/esm/useResponderEvents.mjs
var emptyObject4 = {};
var Attached = /* @__PURE__ */ new WeakMap();
var Ids = /* @__PURE__ */ new WeakMap();
function useResponderEvents(hostRef, configIn = emptyObject4) {
  var _a2;
  const config = getResponderConfigIfDefined(configIn), node2 = ((_a2 = hostRef == null ? void 0 : hostRef.current) == null ? void 0 : _a2.host) || (hostRef == null ? void 0 : hostRef.current);
  React16.useEffect(() => {
    if (config === emptyObject4) return;
    attachListeners(), Ids.has(hostRef) || Ids.set(hostRef, `${Math.random()}`);
    const id = Ids.get(hostRef);
    return addNode(id, node2, config), Attached.set(hostRef, true), () => {
      removeNode(node2), Attached.set(hostRef, false);
    };
  }, [config, hostRef]), React16.useDebugValue({
    isResponder: node2 === getResponderNode()
  }), React16.useDebugValue(config);
}
function getResponderConfigIfDefined({
  onMoveShouldSetResponder,
  onMoveShouldSetResponderCapture,
  onResponderEnd,
  onResponderGrant,
  onResponderMove,
  onResponderReject,
  onResponderRelease,
  onResponderStart,
  onResponderTerminate,
  onResponderTerminationRequest,
  onScrollShouldSetResponder,
  onScrollShouldSetResponderCapture,
  onSelectionChangeShouldSetResponder,
  onSelectionChangeShouldSetResponderCapture,
  onStartShouldSetResponder,
  onStartShouldSetResponderCapture
}) {
  return onMoveShouldSetResponder || onMoveShouldSetResponderCapture || onResponderEnd || onResponderGrant || onResponderMove || onResponderReject || onResponderRelease || onResponderStart || onResponderTerminate || onResponderTerminationRequest || onScrollShouldSetResponder || onScrollShouldSetResponderCapture || onSelectionChangeShouldSetResponder || onSelectionChangeShouldSetResponderCapture || onStartShouldSetResponder || onStartShouldSetResponderCapture ? {
    onMoveShouldSetResponder,
    onMoveShouldSetResponderCapture,
    onResponderEnd,
    onResponderGrant,
    onResponderMove,
    onResponderReject,
    onResponderRelease,
    onResponderStart,
    onResponderTerminate,
    onResponderTerminationRequest,
    onScrollShouldSetResponder,
    onScrollShouldSetResponderCapture,
    onSelectionChangeShouldSetResponder,
    onSelectionChangeShouldSetResponderCapture,
    onStartShouldSetResponder,
    onStartShouldSetResponderCapture
  } : emptyObject4;
}

// node_modules/@tamagui/core/dist/esm/index.mjs
var import_react22 = __toESM(require_react(), 1);

// node_modules/@tamagui/core/dist/esm/getBaseViews.mjs
function getBaseViews() {
  return null;
}

// node_modules/@tamagui/core/dist/esm/helpers/getBoundingClientRect.mjs
var getBoundingClientRect2 = (node2) => {
  var _a2;
  if (!(!node2 || node2.nodeType !== 1)) return (_a2 = node2.getBoundingClientRect) == null ? void 0 : _a2.call(node2);
};

// node_modules/@tamagui/core/dist/esm/helpers/getRect.mjs
var getRect = (node2) => {
  const rect = getBoundingClientRect2(node2);
  if (!rect) return;
  const {
    x,
    y,
    top,
    left
  } = rect;
  return {
    x,
    y,
    width: node2.offsetWidth,
    height: node2.offsetHeight,
    top,
    left
  };
};

// node_modules/@tamagui/core/dist/esm/hooks/useElementLayout.mjs
var LayoutHandlers = /* @__PURE__ */ new WeakMap();
var resizeListeners = /* @__PURE__ */ new Set();
var resizeObserver = null;
if (typeof window < "u" && "ResizeObserver" in window && (resizeObserver = new ResizeObserver((entries) => {
  for (const {
    target
  } of entries) {
    const onLayout = LayoutHandlers.get(target);
    if (typeof onLayout != "function") return;
    measureElement(target).then((event) => {
      onLayout(event);
    });
  }
}), typeof window.addEventListener == "function")) {
  let tm;
  window.addEventListener("resize", () => {
    clearTimeout(tm), tm = setTimeout(() => {
      resizeListeners.forEach((cb) => cb());
    }, 4);
  });
}
var measureElement = async (target) => new Promise((res) => {
  measureLayout(target, null, (x, y, width, height, left, top) => {
    res({
      nativeEvent: {
        layout: {
          x,
          y,
          width,
          height,
          left,
          top
        },
        target
      },
      timeStamp: Date.now()
    });
  });
});
var cache7 = /* @__PURE__ */ new WeakMap();
var measureLayout = (node2, relativeTo, callback) => {
  const relativeNode = relativeTo || (node2 == null ? void 0 : node2.parentNode);
  if (relativeNode instanceof HTMLElement) {
    const now = Date.now();
    cache7.set(node2, now), Promise.all([getBoundingClientRectAsync(node2), getBoundingClientRectAsync(relativeNode)]).then(([nodeDim, relativeNodeDim]) => {
      if (relativeNodeDim && nodeDim && cache7.get(node2) === now) {
        const {
          x,
          y,
          width,
          height,
          left,
          top
        } = getRelativeDimensions(nodeDim, relativeNodeDim);
        callback(x, y, width, height, left, top);
      }
    });
  }
};
var getRelativeDimensions = (a, b) => {
  const {
    height,
    left,
    top,
    width
  } = a, x = left - b.left, y = top - b.top;
  return {
    x,
    y,
    width,
    height,
    left,
    top
  };
};
var getBoundingClientRectAsync = (element) => new Promise((resolve) => {
  function fallbackToSync() {
    resolve(getBoundingClientRect2(element));
  }
  const tm = setTimeout(fallbackToSync, 10);
  new IntersectionObserver((entries, ob) => {
    var _a2;
    clearTimeout(tm), ob.disconnect(), resolve((_a2 = entries[0]) == null ? void 0 : _a2.boundingClientRect);
  }, {
    threshold: 1e-4
  }).observe(element);
});
function useElementLayout(ref, onLayout) {
  var _a2;
  const node2 = (_a2 = ref.current) == null ? void 0 : _a2.host;
  node2 && onLayout && LayoutHandlers.set(node2, onLayout), useIsomorphicLayoutEffect(() => {
    var _a3;
    if (!resizeObserver || !onLayout) return;
    const node22 = (_a3 = ref.current) == null ? void 0 : _a3.host;
    if (!node22) return;
    LayoutHandlers.set(node22, onLayout);
    const onResize = () => {
      measureElement(node22).then(onLayout);
    };
    return resizeListeners.add(onResize), resizeObserver.observe(node22), () => {
      LayoutHandlers.delete(node22), resizeListeners.delete(onResize), resizeObserver == null ? void 0 : resizeObserver.unobserve(node22);
    };
  }, [ref, !!onLayout]);
}

// node_modules/@tamagui/core/dist/esm/addNativeValidStyles.mjs
function addNativeValidStyles() {
}

// node_modules/@tamagui/core/dist/esm/index.mjs
addNativeValidStyles();
var createTamagui2 = (conf4) => createTamagui(conf4);
var baseViews = getBaseViews();
setupHooks({
  getBaseViews,
  setElementProps: (node2) => {
    node2 && !node2.measure && (node2.measure || (node2.measure = (callback) => measureLayout(node2, null, callback)), node2.measureLayout || (node2.measureLayout = (relativeToNode, success) => measureLayout(node2, relativeToNode, success)), node2.measureInWindow || (node2.measureInWindow = (callback) => {
      setTimeout(() => {
        const {
          height,
          left,
          top,
          width
        } = getRect(node2);
        callback(left, top, width, height);
      }, 0);
    }));
  },
  usePropsTransform(elementType, propsIn, stateRef, willHydrate) {
    {
      const isDOM = typeof elementType == "string", {
        // remove event props handles by useResponderEvents
        onMoveShouldSetResponder,
        onMoveShouldSetResponderCapture,
        onResponderEnd,
        onResponderGrant,
        onResponderMove,
        onResponderReject,
        onResponderRelease,
        onResponderStart,
        onResponderTerminate,
        onResponderTerminationRequest,
        onScrollShouldSetResponder,
        onScrollShouldSetResponderCapture,
        onSelectionChangeShouldSetResponder,
        onSelectionChangeShouldSetResponderCapture,
        onStartShouldSetResponder,
        onStartShouldSetResponderCapture,
        // android
        collapsable,
        focusable,
        // deprecated,
        accessible,
        accessibilityDisabled,
        onLayout,
        hrefAttrs,
        ...plainDOMProps
      } = propsIn;
      if ((willHydrate || isDOM) && (useElementLayout(stateRef, isDOM ? onLayout : void 0), useResponderEvents(stateRef, isDOM ? propsIn : void 0)), isDOM) {
        if (plainDOMProps.href && hrefAttrs) {
          const {
            download,
            rel,
            target
          } = hrefAttrs;
          download != null && (plainDOMProps.download = download), rel && (plainDOMProps.rel = rel), typeof target == "string" && (plainDOMProps.target = target.charAt(0) !== "_" ? `_${target}` : target);
        }
        return plainDOMProps;
      }
    }
  },
  useEvents(viewProps, events, {
    pseudos
  }, setStateShallow, staticConfig) {
  }
});
var View2 = View;
var Stack2 = Stack;
var Text2 = Text;

export {
  simpleHash,
  clamp,
  composeEventHandlers,
  concatClassName,
  StyleObjectProperty,
  StyleObjectValue,
  StyleObjectIdentifier,
  StyleObjectPseudo,
  StyleObjectRules,
  isWeb,
  isServer,
  isClient,
  useIsomorphicLayoutEffect,
  isChrome,
  isWebTouchable,
  isTouchable,
  isAndroid,
  isIos,
  currentPlatform,
  shouldRenderNativePlatform,
  tokenCategories,
  stylePropsUnitless,
  stylePropsTransform,
  stylePropsView,
  stylePropsTextOnly,
  stylePropsText,
  stylePropsAll,
  validPseudoKeys,
  validStyles,
  withStaticProperties,
  setConfig,
  getConfig,
  getTokens,
  getToken,
  getTokenValue,
  getThemes,
  updateConfig,
  setupDev,
  createVariable,
  variableToString,
  isVariable,
  getVariable,
  getVariableValue,
  getVariableName,
  matchMedia,
  mediaState,
  mediaQueryConfig,
  getMedia,
  useMedia,
  mediaObjectToString,
  setRef,
  composeRefs,
  useComposedRefs,
  createStyledContext,
  ComponentContext,
  getShorthandValue,
  getCSSStylesAtomic,
  mergeProps,
  createShallowSetState,
  forceUpdateThemes,
  useTheme,
  useDidFinishSSR,
  Theme,
  themeable,
  Slot,
  Slottable,
  createComponent,
  Unspaced,
  Spacer,
  spacedChildren,
  createShorthands,
  createTheme,
  getThemeCSSRules,
  proxyThemeToParents,
  ensureThemeVariable,
  createFont,
  insertFont,
  createTokens,
  setupReactNative,
  styled,
  isTamaguiComponent,
  isTamaguiElement,
  useThemeName,
  useConfiguration,
  useIsTouchDevice,
  Stack,
  useProps,
  useStyle,
  usePropsAndStyle,
  View,
  Text,
  FontLanguage,
  TamaguiProvider,
  Configuration,
  useGet,
  useEvent,
  createMedia,
  createTamagui2 as createTamagui,
  View2,
  Stack2,
  Text2
};
//# sourceMappingURL=chunk-N2HKXBPT.js.map
