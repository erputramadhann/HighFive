{
  "version": 3,
  "sources": ["../../@tamagui/use-force-update/src/index.ts", "../../@tamagui/animate-presence/src/AnimatePresence.tsx", "../../@tamagui/animate-presence/src/LayoutGroupContext.tsx", "../../@tamagui/use-constant/src/index.ts", "../../@tamagui/animate-presence/src/PresenceChild.tsx"],
  "sourcesContent": ["import React from 'react'\n\nexport const isServerSide: boolean =\n  process.env.TAMAGUI_TARGET === 'web' && typeof window === 'undefined'\n\nconst idFn = () => {}\n\nexport function useForceUpdate(): () => void {\n  return isServerSide\n    ? idFn\n    : (React.useReducer((x) => Math.random(), 0)[1] as () => void)\n}\n", "import { useForceUpdate } from '@tamagui/use-force-update'\nimport type { ReactElement, ReactNode } from 'react'\nimport type { FunctionComponent, PropsWithChildren } from 'react'\nimport { Children, cloneElement, isValidElement, useContext, useRef } from 'react'\n\nimport { LayoutGroupContext } from './LayoutGroupContext'\nimport { PresenceChild } from './PresenceChild'\nimport type { AnimatePresenceProps } from './types'\n\ntype ComponentKey = string | number\n\nconst getChildKey = (child: ReactElement<any>): ComponentKey => child.key || ''\n\nfunction updateChildLookup(\n  children: ReactElement<any>[],\n  allChildren: Map<ComponentKey, ReactElement<any>>\n) {\n  children.forEach((child) => {\n    const key = getChildKey(child)\n    allChildren.set(key, child)\n  })\n}\n\nfunction onlyElements(children: ReactNode): ReactElement<any>[] {\n  const filtered: ReactElement<any>[] = []\n  // We use forEach here instead of map as map mutates the component key by preprending `.$`\n  Children.forEach(children, (child) => {\n    if (isValidElement(child)) filtered.push(child)\n  })\n  return filtered\n}\n\nexport const AnimatePresence: FunctionComponent<\n  PropsWithChildren<AnimatePresenceProps>\n> = ({\n  children,\n  enterVariant,\n  exitVariant,\n  enterExitVariant,\n  initial = true,\n  onExitComplete,\n  exitBeforeEnter,\n  presenceAffectsLayout = true,\n  custom,\n}) => {\n  // We want to force a re-render once all exiting animations have finished. We\n  // either use a local forceRender function, or one from a parent context if it exists.\n  let forceRender = useContext(LayoutGroupContext).forceRender ?? useForceUpdate()\n\n  // Filter out any children that aren't ReactElements. We can only track ReactElements with a props.key\n  const filteredChildren = onlyElements(children)\n\n  // Keep a living record of the children we're actually rendering so we\n  // can diff to figure out which are entering and exiting\n  const presentChildren = useRef(filteredChildren)\n\n  // A lookup table to quickly reference components by key\n  const allChildren = useRef(new Map<ComponentKey, ReactElement<any>>()).current\n\n  const exiting = useRef(new Set<ComponentKey>()).current\n  updateChildLookup(filteredChildren, allChildren)\n\n  // If this is the initial component render, just deal with logic surrounding whether\n  // we play onMount animations or not.\n  const isInitialRender = useRef(true)\n\n  if (isInitialRender.current) {\n    isInitialRender.current = false\n    return (\n      <>\n        {filteredChildren.map((child) => (\n          <PresenceChild\n            key={getChildKey(child)}\n            isPresent\n            enterExitVariant={enterExitVariant}\n            exitVariant={exitVariant}\n            enterVariant={enterVariant}\n            initial={initial ? undefined : false}\n            presenceAffectsLayout={presenceAffectsLayout}\n            custom={custom}\n          >\n            {child}\n          </PresenceChild>\n        ))}\n      </>\n    )\n  }\n\n  let childrenToRender = [...filteredChildren]\n\n  // Diff the keys of the currently-present and target children to update our\n  // exiting list.\n  const presentKeys = presentChildren.current.map(getChildKey)\n  const targetKeys = filteredChildren.map(getChildKey)\n\n  // Diff the present children with our target children and mark those that are exiting\n  const numPresent = presentKeys.length\n  for (let i = 0; i < numPresent; i++) {\n    const key = presentKeys[i]\n    if (targetKeys.indexOf(key) === -1) {\n      exiting.add(key)\n    } else {\n      // In case this key has re-entered, remove from the exiting list\n      exiting.delete(key)\n    }\n  }\n\n  // If we currently have exiting children, and we're deferring rendering incoming children\n  // until after all current children have exiting, empty the childrenToRender array\n  if (exitBeforeEnter && exiting.size) {\n    childrenToRender = []\n  }\n\n  // Loop through all currently exiting components and clone them to overwrite `animate`\n  // with any `exit` prop they might have defined.\n  exiting.forEach((key) => {\n    // If this component is actually entering again, early return\n    if (targetKeys.indexOf(key) !== -1) return\n\n    const child = allChildren.get(key)\n    if (!child) return\n\n    const insertionIndex = presentKeys.indexOf(key)\n\n    const onExit = () => {\n      allChildren.delete(key)\n      exiting.delete(key)\n      const removeIndex = presentChildren.current.findIndex(\n        (presentChild) => presentChild.key === key\n      )\n      presentChildren.current.splice(removeIndex, 1)\n\n      if (!exiting.size) {\n        presentChildren.current = filteredChildren\n        forceRender()\n        onExitComplete?.()\n      }\n    }\n\n    const exitingComponent = (\n      <PresenceChild\n        key={getChildKey(child)}\n        isPresent={false}\n        onExitComplete={onExit}\n        presenceAffectsLayout={presenceAffectsLayout}\n        enterExitVariant={enterExitVariant}\n        enterVariant={enterVariant}\n        exitVariant={exitVariant}\n        custom={custom}\n      >\n        {child}\n      </PresenceChild>\n    )\n\n    childrenToRender.splice(insertionIndex, 0, exitingComponent)\n  })\n\n  // Add `MotionContext` even to children that don't need it to ensure we're rendering\n  // the same tree between renders\n  childrenToRender = childrenToRender.map((child) => {\n    const key = child.key as ComponentKey\n    return exiting.has(key) ? (\n      child\n    ) : (\n      <PresenceChild\n        key={getChildKey(child)}\n        isPresent\n        exitVariant={exitVariant}\n        enterVariant={enterVariant}\n        enterExitVariant={enterExitVariant}\n        presenceAffectsLayout={presenceAffectsLayout}\n        custom={custom}\n      >\n        {child}\n      </PresenceChild>\n    )\n  })\n\n  presentChildren.current = childrenToRender\n\n  return (\n    <>\n      {exiting.size\n        ? childrenToRender\n        : // biome-ignore lint/correctness/useJsxKeyInIterable: <explanation>\n          childrenToRender.map((child) => cloneElement(child))}\n    </>\n  )\n}\n\nAnimatePresence.displayName = 'AnimatePresence'\n", "import React from 'react'\n\nexport interface LayoutGroupContextProps {\n  id?: string\n  forceRender?: VoidFunction\n}\n\nexport const LayoutGroupContext = React.createContext<LayoutGroupContextProps>({})\n", "import * as React from 'react'\n\ntype ResultBox<T> = { v: T }\n\nexport function useConstant<T>(fn: () => T): T {\n  // RSC compat\n  if (typeof document === 'undefined') {\n    return React.useMemo(() => fn(), [])\n  }\n\n  const ref = React.useRef<ResultBox<T>>()\n\n  if (!ref.current) {\n    ref.current = { v: fn() }\n  }\n\n  return ref.current.v\n}\n", "import { useConstant } from '@tamagui/use-constant'\nimport { PresenceContext } from '@tamagui/use-presence'\nimport type { PresenceContextProps } from '@tamagui/web'\nimport * as React from 'react'\nimport { useId } from 'react'\n\nimport type { VariantLabels } from './types'\n\ninterface PresenceChildProps {\n  children: React.ReactElement<any>\n  isPresent: boolean\n  onExitComplete?: () => void\n  initial?: false | VariantLabels\n  custom?: any\n  presenceAffectsLayout: boolean\n  exitVariant?: string | null\n  enterVariant?: string | null\n  enterExitVariant?: string | null\n}\n\n// this memo seems to help PopoverContent from continuously re-rendering when open\nexport const PresenceChild = React.memo(\n  ({\n    children,\n    initial,\n    isPresent,\n    onExitComplete,\n    exitVariant,\n    enterVariant,\n    enterExitVariant,\n    presenceAffectsLayout,\n    custom,\n  }: PresenceChildProps) => {\n    const presenceChildren = useConstant(newChildrenMap)\n    const id = useId() || ''\n\n    const context = React.useMemo(\n      (): PresenceContextProps => {\n        return {\n          id,\n          initial,\n          isPresent,\n          custom,\n          exitVariant,\n          enterVariant,\n          enterExitVariant,\n          onExitComplete: () => {\n            presenceChildren.set(id, true)\n            for (const isComplete of presenceChildren.values()) {\n              if (!isComplete) {\n                return // can stop searching when any is incomplete\n              }\n            }\n            onExitComplete?.()\n          },\n          register: () => {\n            presenceChildren.set(id, false)\n            return () => presenceChildren.delete(id)\n          },\n        }\n      },\n      /**\n       * If the presence of a child affects the layout of the components around it,\n       * we want to make a new context value to ensure they get re-rendered\n       * so they can detect that layout change.\n       */\n\n      // @ts-expect-error its ok\n      presenceAffectsLayout ? undefined : [isPresent, exitVariant, enterVariant]\n    )\n\n    React.useMemo(() => {\n      presenceChildren.forEach((_, key) => presenceChildren.set(key, false))\n    }, [isPresent])\n\n    /**\n     * If there's no animated components to fire exit animations, we want to remove this\n     * component immediately.\n     */\n    React.useEffect(() => {\n      !isPresent && !presenceChildren.size && onExitComplete?.()\n    }, [isPresent])\n\n    return <PresenceContext.Provider value={context}>{children}</PresenceContext.Provider>\n  }\n)\n\nfunction newChildrenMap(): Map<string, boolean> {\n  return new Map()\n}\n"],
  "mappings": "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",
  "names": ["isServerSide", "window", "idFn", "useForceUpdate", "React", "useReducer", "x", "Math", "random", "import_react", "import_react", "LayoutGroupContext", "React", "createContext", "React", "useConstant", "fn", "document", "useMemo", "ref", "useRef", "current", "v", "React", "import_react", "PresenceChild", "memo", "children", "initial", "isPresent", "onExitComplete", "exitVariant", "enterVariant", "enterExitVariant", "presenceAffectsLayout", "custom", "presenceChildren", "useConstant", "newChildrenMap", "id", "useId", "context", "useMemo", "set", "isComplete", "values", "register", "delete", "forEach", "_", "key", "useEffect", "size", "jsx", "PresenceContext", "Provider", "value", "Map", "import_jsx_runtime", "getChildKey", "child", "key", "updateChildLookup", "children", "allChildren", "forEach", "set", "onlyElements", "filtered", "Children", "isValidElement", "push", "AnimatePresence", "enterVariant", "exitVariant", "enterExitVariant", "initial", "onExitComplete", "exitBeforeEnter", "presenceAffectsLayout", "custom", "forceRender", "useContext", "LayoutGroupContext", "useForceUpdate", "filteredChildren", "presentChildren", "useRef", "Map", "current", "exiting", "Set", "isInitialRender", "jsx", "Fragment", "map", "PresenceChild", "isPresent", "childrenToRender", "presentKeys", "targetKeys", "numPresent", "length", "i", "indexOf", "add", "delete", "size", "get", "insertionIndex", "exitingComponent", "removeIndex", "findIndex", "presentChild", "splice", "has", "cloneElement", "displayName"]
}
