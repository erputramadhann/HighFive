import {
  PresenceContext
} from "./chunk-4IITRGBK.js";
import {
  require_jsx_runtime
} from "./chunk-OT5EQO2H.js";
import {
  require_react
} from "./chunk-OU5AQDZK.js";
import {
  __toESM
} from "./chunk-EWTE5DHJ.js";

// node_modules/@tamagui/use-force-update/dist/esm/index.mjs
var import_react = __toESM(require_react(), 1);
var isServerSide = typeof window > "u";
var idFn = () => {
};
function useForceUpdate() {
  return isServerSide ? idFn : import_react.default.useReducer((x) => Math.random(), 0)[1];
}

// node_modules/@tamagui/animate-presence/dist/esm/AnimatePresence.mjs
var import_react4 = __toESM(require_react(), 1);

// node_modules/@tamagui/animate-presence/dist/esm/LayoutGroupContext.mjs
var import_react2 = __toESM(require_react(), 1);
var LayoutGroupContext = import_react2.default.createContext({});

// node_modules/@tamagui/use-constant/dist/esm/index.mjs
var React3 = __toESM(require_react(), 1);
function useConstant(fn) {
  if (typeof document > "u") return React3.useMemo(() => fn(), []);
  const ref = React3.useRef();
  return ref.current || (ref.current = {
    v: fn()
  }), ref.current.v;
}

// node_modules/@tamagui/animate-presence/dist/esm/PresenceChild.mjs
var React4 = __toESM(require_react(), 1);
var import_react3 = __toESM(require_react(), 1);
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var PresenceChild = React4.memo(({
  children,
  initial,
  isPresent,
  onExitComplete,
  exitVariant,
  enterVariant,
  enterExitVariant,
  presenceAffectsLayout,
  custom
}) => {
  const presenceChildren = useConstant(newChildrenMap), id = (0, import_react3.useId)() || "", context = React4.useMemo(
    () => ({
      id,
      initial,
      isPresent,
      custom,
      exitVariant,
      enterVariant,
      enterExitVariant,
      onExitComplete: () => {
        presenceChildren.set(id, true);
        for (const isComplete of presenceChildren.values()) if (!isComplete) return;
        onExitComplete == null ? void 0 : onExitComplete();
      },
      register: () => (presenceChildren.set(id, false), () => presenceChildren.delete(id))
    }),
    /**
     * If the presence of a child affects the layout of the components around it,
     * we want to make a new context value to ensure they get re-rendered
     * so they can detect that layout change.
     */
    // @ts-expect-error its ok
    presenceAffectsLayout ? void 0 : [isPresent, exitVariant, enterVariant]
  );
  return React4.useMemo(() => {
    presenceChildren.forEach((_, key) => presenceChildren.set(key, false));
  }, [isPresent]), React4.useEffect(() => {
    !isPresent && !presenceChildren.size && (onExitComplete == null ? void 0 : onExitComplete());
  }, [isPresent]), (0, import_jsx_runtime.jsx)(PresenceContext.Provider, {
    value: context,
    children
  });
});
function newChildrenMap() {
  return /* @__PURE__ */ new Map();
}

// node_modules/@tamagui/animate-presence/dist/esm/AnimatePresence.mjs
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
var getChildKey = (child) => child.key || "";
function updateChildLookup(children, allChildren) {
  children.forEach((child) => {
    const key = getChildKey(child);
    allChildren.set(key, child);
  });
}
function onlyElements(children) {
  const filtered = [];
  return import_react4.Children.forEach(children, (child) => {
    (0, import_react4.isValidElement)(child) && filtered.push(child);
  }), filtered;
}
var AnimatePresence = ({
  children,
  enterVariant,
  exitVariant,
  enterExitVariant,
  initial = true,
  onExitComplete,
  exitBeforeEnter,
  presenceAffectsLayout = true,
  custom
}) => {
  let forceRender = (0, import_react4.useContext)(LayoutGroupContext).forceRender ?? useForceUpdate();
  const filteredChildren = onlyElements(children), presentChildren = (0, import_react4.useRef)(filteredChildren), allChildren = (0, import_react4.useRef)(/* @__PURE__ */ new Map()).current, exiting = (0, import_react4.useRef)(/* @__PURE__ */ new Set()).current;
  updateChildLookup(filteredChildren, allChildren);
  const isInitialRender = (0, import_react4.useRef)(true);
  if (isInitialRender.current) return isInitialRender.current = false, (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, {
    children: filteredChildren.map((child) => (0, import_jsx_runtime2.jsx)(PresenceChild, {
      isPresent: true,
      enterExitVariant,
      exitVariant,
      enterVariant,
      initial: initial ? void 0 : false,
      presenceAffectsLayout,
      custom,
      children: child
    }, getChildKey(child)))
  });
  let childrenToRender = [...filteredChildren];
  const presentKeys = presentChildren.current.map(getChildKey), targetKeys = filteredChildren.map(getChildKey), numPresent = presentKeys.length;
  for (let i = 0; i < numPresent; i++) {
    const key = presentKeys[i];
    targetKeys.indexOf(key) === -1 ? exiting.add(key) : exiting.delete(key);
  }
  return exitBeforeEnter && exiting.size && (childrenToRender = []), exiting.forEach((key) => {
    if (targetKeys.indexOf(key) !== -1) return;
    const child = allChildren.get(key);
    if (!child) return;
    const insertionIndex = presentKeys.indexOf(key), exitingComponent = (0, import_jsx_runtime2.jsx)(PresenceChild, {
      isPresent: false,
      onExitComplete: () => {
        allChildren.delete(key), exiting.delete(key);
        const removeIndex = presentChildren.current.findIndex((presentChild) => presentChild.key === key);
        presentChildren.current.splice(removeIndex, 1), exiting.size || (presentChildren.current = filteredChildren, forceRender(), onExitComplete == null ? void 0 : onExitComplete());
      },
      presenceAffectsLayout,
      enterExitVariant,
      enterVariant,
      exitVariant,
      custom,
      children: child
    }, getChildKey(child));
    childrenToRender.splice(insertionIndex, 0, exitingComponent);
  }), childrenToRender = childrenToRender.map((child) => {
    const key = child.key;
    return exiting.has(key) ? child : (0, import_jsx_runtime2.jsx)(PresenceChild, {
      isPresent: true,
      exitVariant,
      enterVariant,
      enterExitVariant,
      presenceAffectsLayout,
      custom,
      children: child
    }, getChildKey(child));
  }), presentChildren.current = childrenToRender, (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, {
    children: exiting.size ? childrenToRender : (
      // biome-ignore lint/correctness/useJsxKeyInIterable: <explanation>
      childrenToRender.map((child) => (0, import_react4.cloneElement)(child))
    )
  });
};
AnimatePresence.displayName = "AnimatePresence";

export {
  isServerSide,
  useForceUpdate,
  useConstant,
  PresenceChild,
  AnimatePresence
};
//# sourceMappingURL=chunk-KNEZWNEE.js.map
