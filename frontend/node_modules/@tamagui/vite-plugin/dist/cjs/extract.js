var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf, __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: !0 });
}, __copyProps = (to, from, except, desc) => {
  if (from && typeof from == "object" || typeof from == "function")
    for (let key of __getOwnPropNames(from))
      !__hasOwnProp.call(to, key) && key !== except && __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: !0 }) : target,
  mod
)), __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: !0 }), mod);
var extract_exports = {};
__export(extract_exports, {
  tamaguiExtractPlugin: () => tamaguiExtractPlugin
});
module.exports = __toCommonJS(extract_exports);
var import_node_path = __toESM(require("node:path"), 1), import_vite = require("vite"), import_loadTamagui = require("./loadTamagui"), import_node_crypto = require("node:crypto");
function tamaguiExtractPlugin(optionsIn) {
  if (optionsIn?.disable)
    return {
      name: "tamagui-extract"
    };
  const getHash = (input) => (0, import_node_crypto.createHash)("sha1").update(input).digest("base64"), clearCompilerCache = () => {
    memoryCache = {}, cacheSize = 0;
  };
  let memoryCache = {}, cacheSize = 0;
  const cssMap = /* @__PURE__ */ new Map();
  let config, server;
  const virtualExt = ".tamagui.css", getAbsoluteVirtualFileId = (filePath) => filePath.startsWith(config.root) ? filePath : (0, import_vite.normalizePath)(import_node_path.default.join(config.root, filePath));
  function isVite6AndNotClient(environment) {
    return environment?.name && environment.name !== "client";
  }
  function isVite6Native(environment) {
    return environment?.name && (environment.name === "ios" || environment.name === "android");
  }
  function invalidateModule(absoluteId) {
    if (!server) return;
    const { moduleGraph } = server, modules = moduleGraph.getModulesByFile(absoluteId);
    if (modules)
      for (const module2 of modules)
        moduleGraph.invalidateModule(module2), module2.lastHMRTimestamp = module2.lastInvalidationTimestamp || Date.now();
  }
  return {
    name: "tamagui-extract",
    enforce: "pre",
    configureServer(_server) {
      server = _server;
    },
    async buildStart() {
      await (0, import_loadTamagui.loadTamaguiBuildConfig)(optionsIn);
    },
    buildEnd() {
      import_loadTamagui.extractor?.cleanupBeforeExit();
    },
    config(userConf) {
      userConf.optimizeDeps ||= {}, userConf.optimizeDeps.include ||= [], userConf.optimizeDeps.include.push("@tamagui/core/inject-styles");
    },
    async configResolved(resolvedConfig) {
      config = resolvedConfig;
    },
    async resolveId(source) {
      if (isVite6Native(this.environment) || import_loadTamagui.tamaguiOptions?.disableServerOptimization && isVite6AndNotClient(this.environment))
        return;
      const [validId, query] = source.split("?");
      if (!validId.endsWith(virtualExt))
        return;
      const absoluteId = source.startsWith(config.root) ? source : getAbsoluteVirtualFileId(validId);
      if (cssMap.has(absoluteId))
        return absoluteId + (query ? `?${query}` : "");
    },
    /**
     * TODO
     *
     *   mainFields module:jsx breaks, so lets just have a mapping here
     *   where we load() and map it to the jsx path before transform
     *
     */
    async load(id) {
      if (import_loadTamagui.disableStatic || isVite6Native(this.environment) || import_loadTamagui.tamaguiOptions?.disableServerOptimization && isVite6AndNotClient(this.environment))
        return;
      const [validId] = id.split("?");
      return cssMap.get(validId);
    },
    transform: {
      order: "pre",
      async handler(code, id) {
        if (import_loadTamagui.disableStatic || isVite6Native(this.environment) || import_loadTamagui.tamaguiOptions?.disableServerOptimization && isVite6AndNotClient(this.environment))
          return;
        const [validId] = id.split("?");
        if (!validId.endsWith(".tsx"))
          return;
        const firstCommentIndex = code.indexOf("// "), { shouldDisable, shouldPrintDebug } = import_loadTamagui.Static.getPragmaOptions({
          source: firstCommentIndex >= 0 ? code.slice(firstCommentIndex) : "",
          path: validId
        });
        if (shouldPrintDebug && (console.trace(
          `Current file: ${id} in environment: ${this.environment?.name}, shouldDisable: ${shouldDisable}`
        ), console.info(`

Original source:
${code}

`)), shouldDisable)
          return;
        const cacheEnv = this.environment.name === "client" || this.environment.name === "ssr" ? (
          // same cache key for ssr and web since they are the same
          "web"
        ) : this.environment.name, cacheKey = getHash(`${cacheEnv}${code}${id}`), cached = memoryCache[cacheKey];
        if (cached)
          return cached;
        const extracted = await import_loadTamagui.Static.extractToClassNames({
          extractor: import_loadTamagui.extractor,
          source: code,
          sourcePath: validId,
          options: import_loadTamagui.tamaguiOptions,
          shouldPrintDebug
        });
        if (!extracted)
          return;
        const rootRelativeId = `${validId}${virtualExt}`, absoluteId = getAbsoluteVirtualFileId(rootRelativeId);
        let source = extracted.js;
        extracted.styles && (this.addWatchFile(rootRelativeId), server && cssMap.has(absoluteId) && invalidateModule(rootRelativeId), source = `${source}
import "${rootRelativeId}";`, cssMap.set(absoluteId, extracted.styles));
        const codeOut = source.toString(), out = {
          code: codeOut,
          map: extracted.map
        };
        return cacheSize += codeOut.length, cacheSize > 26214400 && clearCompilerCache(), memoryCache[cacheKey] = out, out;
      }
    }
  };
}
//# sourceMappingURL=extract.js.map
